<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hexo</title>
    <url>/2021/05/28/Hexo/</url>
    <content><![CDATA[<h2 id="快速开始-Hexo"><a href="#快速开始-Hexo" class="headerlink" title="快速开始 Hexo"></a>快速开始 Hexo</h2><span id="more"></span>

<h3 id="创建一个新文章"><a href="#创建一个新文章" class="headerlink" title="创建一个新文章"></a>创建一个新文章</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="运行服务器"><a href="#运行服务器" class="headerlink" title="运行服务器"></a>运行服务器</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br><span class="line">$ <span class="comment"># hexo s</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br><span class="line">$ <span class="comment"># hexo g</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="发布到远程网站"><a href="#发布到远程网站" class="headerlink" title="发布到远程网站"></a>发布到远程网站</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br><span class="line">$ <span class="comment">#hexo d</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 126.单词接龙 ||</title>
    <url>/2021/06/21/LeetCode/leetcode-126/</url>
    <content><![CDATA[<h3 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h3><p>给定两个单词（beginWord 和 endWord）和一个字典 wordList，找出所有从 beginWord 到 endWord 的最短转换序列。转换需遵循如下规则：</p>
<p>每次转换只能改变一个字母。<br>转换后得到的单词必须是字典中的单词。<br>说明:</p>
<ul>
<li>如果不存在这样的转换序列，返回一个空列表。</li>
<li>所有单词具有相同的长度。</li>
<li>所有单词只由小写字母组成。</li>
<li>字典中不存在重复的单词。</li>
<li>你可以假设 beginWord 和 endWord 是非空的，且二者不相同。<span id="more"></span>
<h3 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">beginWord = &quot;hit&quot;,</span><br><span class="line">endWord = &quot;cog&quot;,</span><br><span class="line">wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [&quot;hit&quot;,&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;cog&quot;],</span><br><span class="line">  [&quot;hit&quot;,&quot;hot&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">beginWord = &quot;hit&quot;</span><br><span class="line">endWord = &quot;cog&quot;</span><br><span class="line">wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]</span><br><span class="line"></span><br><span class="line">输出: []</span><br><span class="line"></span><br><span class="line">解释: endWord &quot;cog&quot; 不在字典中，所以不存在符合要求的转换序列。</span><br></pre></td></tr></table></figure>

<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>根据题意先将单词表构成一个无向图，然后bfs搜索路径。</p>
<p>这里注意，因为要求返回全部最短路径，所以bfs的队列中单纯的存节点行不通（<del>Maybe可以吧</del>）。</p>
<p>这里我们存路径，也就是<strong>从起点到这个点的路径</strong>，其他的和普通bfs没什么两样。</p>
<p>另外就是时间卡的有点紧，在构图的时候没有那句<code>if(tmp &gt; 1) break;</code>就超时了？？找个时间优化一下算法。</p>
<hr>
<p>( 这个题确实有点让人头大，还是太菜了</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;string&gt;&gt; <span class="built_in">findLadders</span>(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList) &#123;</span><br><span class="line">    <span class="keyword">int</span> n, len, beg, end;</span><br><span class="line">    unordered_map&lt;string, <span class="keyword">int</span>&gt; wti;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; G;  </span><br><span class="line">    vector&lt;string&gt; words;  <span class="comment">//拷贝单词表</span></span><br><span class="line"></span><br><span class="line">    n = wordList.<span class="built_in">size</span>(); <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    len = wordList[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    words = wordList;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        wti[words[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!wti.<span class="built_in">count</span>(endWord)) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    <span class="keyword">if</span>(!wti.<span class="built_in">count</span>(beginWord)) &#123; words.<span class="built_in">push_back</span>(beginWord); wti[beginWord] = n++; &#125;</span><br><span class="line">    </span><br><span class="line">    beg = wti[beginWord];</span><br><span class="line">    end = wti[endWord];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构图</span></span><br><span class="line">    G.<span class="built_in">resize</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; len; k++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(words[i][k] != words[j][k]) tmp++;</span><br><span class="line">                <span class="keyword">if</span>(tmp &gt; <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(tmp == <span class="number">1</span>) &#123;</span><br><span class="line">                G[i].<span class="built_in">push_back</span>(j);</span><br><span class="line">                G[j].<span class="built_in">push_back</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; ans;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//搜路</span></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dis</span><span class="params">(n, <span class="number">0x3f3f3f</span>)</span></span>;</span><br><span class="line">    dis[beg] = <span class="number">0</span>;</span><br><span class="line">    queue&lt;vector&lt;string&gt;&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;beginWord&#125;);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        vector&lt;string&gt; path = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">int</span> u = wti[path.<span class="built_in">back</span>()];</span><br><span class="line">        <span class="keyword">if</span>(u == end) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> v : G[u]) &#123;</span><br><span class="line">                <span class="keyword">if</span>(dis[u] + <span class="number">1</span> &lt;= dis[v]) &#123;</span><br><span class="line">                    vector&lt;string&gt; tmp = path;</span><br><span class="line">                    tmp.<span class="built_in">push_back</span>(words[v]);</span><br><span class="line">                    q.<span class="built_in">push</span>(tmp);</span><br><span class="line">                    dis[v] = dis[u] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>搜索</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 128.最长连续序列</title>
    <url>/2021/06/22/LeetCode/leetcode-128/</url>
    <content><![CDATA[<h3 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h3><p>给定一个未排序的整数数组，找出最长连续序列的长度。</p>
<p>要求算法的**时间复杂度为 O(n)**。</p>
<span id="more"></span>
<h3 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [100, 4, 200, 1, 3, 2]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 最长连续序列是 [1, 2, 3, 4]。它的长度为 4。</span><br></pre></td></tr></table></figure>

<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>要求时间复杂度为 $O(n)$ 自然是<strong>不能排序</strong>了，并查集可以把<strong>属性相似的一类数聚在一起的作用</strong>，而且压缩后的并查集时间复杂度也很可观。</p>
<ul>
<li><p>先初始化数组中每一个数指向本身。</p>
</li>
<li><p>循环数组</p>
<ul>
<li><p>如果 $nums[i] + 1$ 在并查集中， $nums[i] + 1$ 指向 $nums[i]$。</p>
</li>
<li><p>如果 $nums[i] - 1$ 在并查集中， $nums[i]$ 指向 $nums[i] - 1$。</p>
</li>
</ul>
</li>
</ul>
<p><strong>⚠这题依然有个空数组问题，又被坑了。。。</strong></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; p;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x == p[x] ? x : p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.<span class="built_in">size</span>(); <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> item : nums) &#123; p[item] = item; &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> item : nums) &#123;</span><br><span class="line">        <span class="keyword">if</span>(p.<span class="built_in">count</span>(item + <span class="number">1</span>)) p[item + <span class="number">1</span>] = item;</span><br><span class="line">        <span class="keyword">if</span>(p.<span class="built_in">count</span>(item - <span class="number">1</span>)) p[item] = item - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> item : nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="built_in">find</span>(item);</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, item - temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 238.除自身以外数组的乘积</title>
    <url>/2021/06/22/LeetCode/leetcode-238/</url>
    <content><![CDATA[<h3 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h3><p>给你一个长度为 n 的整数数组 nums，其中 n &gt; 1，返回输出数组 output ，其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。</p>
<p><strong>提示</strong>：题目数据保证数组之中任意元素的全部前缀元素和后缀（甚至是整个数组）的乘积都在 32 位整数范围内。</p>
<p><strong>说明</strong>: 请不要使用除法，且在 O(n) 时间复杂度内完成此题。</p>
<p><strong>进阶</strong>：你可以在常数空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组不被视为额外空间。)</p>
<span id="more"></span>
<h3 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3,4]</span><br><span class="line">输出: [24,12,8,6]</span><br></pre></td></tr></table></figure>

<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul>
<li><p>常规做法<br>  一看到的一下子想到的可能就是把所有数累乘起来，然后<strong>循环</strong>一边，循环到那个数就<strong>除掉</strong>哪个数。但是注意如果这个题是累加的话可以这样做，但是这个题是累乘，如果有一个位置是0，这时候就会出错。</p>
<p>  所以考虑另一种方法，将数组做一次<strong>前缀和后缀累乘</strong>，循环到某个数的时候将该数<strong>前缀乘以后缀</strong>即可</p>
</li>
<li><p>进阶做法<br>  在进阶里面要求到常数空间复杂度，如果是按照常规做法，需要用到<strong>left和right</strong>两个数组分别存<strong>前缀和后缀</strong>，另外还得开一个答案数组去存储计算答案。这样空间复杂度明显是 $O(n)$ ，因为题目要求中讲到</p>
<blockquote>
<p>出于对空间复杂度分析的目的，输出数组不被视为额外空间。</p>
</blockquote>
<p>  也就是常数空间复杂度的话就需要把答案数组拿进来<strong>重新利用</strong>，于是可以想到如下做法</p>
<blockquote>
<p>假设nums[] = {a, b, c, d}<br>  令ans[] = {1, a, ab, abc}<br>  然后倒着计算一边ans数组使得<br>  ans[] = {1 * bcd, a * cd, ab * d, abc}</p>
</blockquote>
<p>  这不刚好就是答案吗。这个题的做法就出来了</p>
</li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><ul>
<li><p>常规做法</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">productExceptSelf</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">left</span><span class="params">(n)</span>, <span class="title">right</span><span class="params">(n)</span>, <span class="title">ans</span><span class="params">(n)</span></span>;</span><br><span class="line">    </span><br><span class="line">    left[<span class="number">0</span>] = nums[<span class="number">0</span>]; right[n - <span class="number">1</span>] = nums[n - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123; left[i] = nums[i] * left[i - <span class="number">1</span>]; &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123; right[i] = nums[i] * right[i + <span class="number">1</span>]; &#125;</span><br><span class="line">    </span><br><span class="line">    ans[<span class="number">0</span>] = right[<span class="number">1</span>]; ans[n - <span class="number">1</span>] = left[n - <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        ans[i] = left[i - <span class="number">1</span>] * right[i + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>进阶做法</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">productExceptSelf</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123; </span><br><span class="line">        ans[i] = ans[i - <span class="number">1</span>] * nums[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> tmp = nums[n - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        ans[i] *= tmp;</span><br><span class="line">        tmp *= nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 15.新21点</title>
    <url>/2021/06/20/LeetCode/leetcode-15/</url>
    <content><![CDATA[<h3 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h3><p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。</p>
<p><strong>注意</strong>：答案中不可以包含重复的三元组。</p>
<span id="more"></span>
<h3 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [-1, 0, 1, 2, -1, 4]</span><br><span class="line">输出：ans = [[-1, 0, 1], [-1, -1, 2]]</span><br></pre></td></tr></table></figure>

<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>排序+双指针+vector数组去重，去重有两种方式🙂</p>
<ul>
<li><p>vector + set去重<br><code>set&lt;vector&lt;int&gt;&gt; s(ans.begin(), ans.end());</code><br><code>ans.assign(s.begin(), s.end());</code></p>
<p>  过是可以过，但是….<br>  <a href="https://imgtu.com/i/RuxDV1"><img src="https://z3.ax1x.com/2021/06/23/RuxDV1.png" alt="RuxDV1.png"></a></p>
</li>
<li><p>第二种就是在代码里面去重，如果碰到重复的就跳过，这个不算太差..<br>  <a href="https://imgtu.com/i/Rux0bR"><img src="https://z3.ax1x.com/2021/06/23/Rux0bR.png" alt="Rux0bR.png"></a></p>
</li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span>(nums.<span class="built_in">size</span>() &lt; <span class="number">3</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">2</span> &amp;&amp; nums[i] &lt;= <span class="number">0</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> l = i + <span class="number">1</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = nums[i] + nums[l] + nums[r];</span><br><span class="line">            <span class="keyword">if</span>(tmp &gt; <span class="number">0</span>) r--;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(tmp &lt; <span class="number">0</span>) l++;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">while</span>(l &lt; r &amp;&amp; nums[l] == nums[l + <span class="number">1</span>]) l++;</span><br><span class="line">                <span class="keyword">while</span>(l &lt; r &amp;&amp; nums[r] == nums[r - <span class="number">1</span>]) r--;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(&#123;nums[i], nums[l], nums[r]&#125;);</span><br><span class="line">                l++; r--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 29.顺时针打印矩阵</title>
    <url>/2021/06/21/LeetCode/leetcode-29/</url>
    <content><![CDATA[<h3 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h3><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p>
<span id="more"></span>
<h3 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">输出：[1,2,3,6,9,8,7,4,5]</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]</span><br><span class="line">输出：[1,2,3,4,8,12,11,10,9,5,6,7]</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 &lt;= matrix.length &lt;= 100</span><br><span class="line">0 &lt;= matrix[i].length &lt;= 100</span><br></pre></td></tr></table></figure>

<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>直接按照题意转就好了，这道题虽然标的Easy，但还是被<strong>空向量</strong>和<strong>数据范围不明确</strong>给坑了一下。。</p>
<p>没有数据范围，我直接把访问过的地方标记 $0x3f3f3f3f$ 但其实这种做法是不对的，正确的做法是使用另一个 $vis$ 数组，$vis[i][j]$ 表示$i,j$ 这个位置输出过了。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ok</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> &lt;= x &amp;&amp; x &lt; n &amp;&amp; <span class="number">0</span> &lt;= y &amp;&amp; y &lt; m;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">spiralOrder</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = matrix.<span class="built_in">size</span>(); <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    <span class="keyword">int</span> m = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(n * m)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>, tmp = <span class="number">0</span>, inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> d[<span class="number">4</span>][<span class="number">2</span>] = &#123; &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125; &#125;;</span><br><span class="line">    ans[cnt++] = matrix[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    matrix[x][y] = inf;</span><br><span class="line">    <span class="keyword">while</span>(cnt &lt; n * m) &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">ok</span>(x + d[tmp][<span class="number">0</span>], y + d[tmp][<span class="number">1</span>], n, m) &amp;&amp; matrix[x + d[tmp][<span class="number">0</span>]][y + d[tmp][<span class="number">1</span>]] != inf) &#123;</span><br><span class="line">            ans[cnt++] = matrix[x + d[tmp][<span class="number">0</span>]][y + d[tmp][<span class="number">1</span>]];</span><br><span class="line">            matrix[x + d[tmp][<span class="number">0</span>]][y + d[tmp][<span class="number">1</span>]] = inf;</span><br><span class="line">            x += d[tmp][<span class="number">0</span>];</span><br><span class="line">            y += d[tmp][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        tmp = (tmp + <span class="number">1</span>) % <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 42.连续子数组的最大和</title>
    <url>/2021/06/21/LeetCode/leetcode-42/</url>
    <content><![CDATA[<h3 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h3><p>输入一个整型数组，数组里有正数也有负数。数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。</p>
<p>要求<strong>时间复杂度</strong>为 $O(n)$ 。</p>
<span id="more"></span>
<h3 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class="line">输出: 6</span><br><span class="line">解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 &lt;= arr.length &lt;= 10^5</span><br><span class="line">-100 &lt;= arr[i] &lt;= 100</span><br></pre></td></tr></table></figure>

<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p><strong>状态定义</strong>：$dp[i]$ = 以$nums[i]$为结尾的连续子数组的和的最大值</p>
<p><strong>转移方程</strong>：若 $dp[i-1] \leq 0$ ，说明 $dp[i−1]$ 对 $dp[i]$ 产生负贡献，即 $dp[i-1] + nums[i]$ 还不如 $nums[i]$ 本身大。</p>
<ul>
<li><p>当 $dp[i-1] \leq 0$，$dp[i]=nums[i]$</p>
</li>
<li><p>当 $dp[i-1]&gt;0$，$dp[i] = dp[i-1]+nums[i]$</p>
</li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> ans = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        dp[i] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>] + nums[i], nums[i]);</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, dp[i]); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 837.新21点</title>
    <url>/2021/06/22/LeetCode/leetcode-837/</url>
    <content><![CDATA[<h3 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h3><p>爱丽丝参与一个大致基于纸牌游戏 “21点” 规则的游戏，描述如下：</p>
<p>爱丽丝以 0 分开始，并在她的得分少于 K 分时抽取数字。 抽取时，她从 [1, W] 的范围中随机获得一个整数作为分数进行累计，其中 W 是整数。 每次抽取都是独立的，其结果具有相同的概率。</p>
<p>当爱丽丝获得不少于 K 分时，她就停止抽取数字。 爱丽丝的分数不超过 N 的概率是多少？</p>
<span id="more"></span>
<h3 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：N = 10, K = 1, W = 10</span><br><span class="line">输出：1.00000</span><br><span class="line">说明：爱丽丝得到一张卡，然后停止。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：N = 6, K = 1, W = 10</span><br><span class="line">输出：0.60000</span><br><span class="line">说明：爱丽丝得到一张卡，然后停止。</span><br><span class="line">在 W = 10 的 6 种可能下，她的得分不超过 N = 6 分。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：N = 21, K = 17, W = 10</span><br><span class="line">输出：0.73278</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 0 &lt;= K &lt;= N &lt;= 10000</span><br><span class="line">2. 1 &lt;= W &lt;= 10000</span><br><span class="line">3. 如果答案与正确答案的误差不超过 10^-5，则该答案将被视为正确答案通过。</span><br></pre></td></tr></table></figure>

<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>定义这样的<strong>dp数组</strong><br>$$dp[i] = 令初始分数为i，抽牌结束后不超过N的概率$$</p>
<p>初始化 $dp$ 数组的时候 $dp[i]=1,i \in [K,N]$ $dp[i]=0,i \in (N,+ \infty )$ </p>
<p>当<strong>初始分数</strong>为 $K-1$ 时，很明显知道<strong>概率</strong>为 $P= \frac{\sum_{i=K}^{K+W} dp[i]}{W}$ ，这时顺着公式从k-1推回0即可。</p>
<p>但是这里注意一下数据范围，如果是这样先循环一个 $K$ ，再循环 $W$ ，时间复杂度会很高所以在处理的时候注意一下那一段 $\sum_{i=K}^{K+W} dp[i]$ ，<strong>计算的时候可以减去区间后面的，再加上区间前面的。</strong></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">new21Game</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> K, <span class="keyword">int</span> W)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">double</span>&gt; <span class="title">dp</span><span class="params">(N + W + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = K; i &lt;= N; i++) dp[i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">double</span> tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = K + <span class="number">1</span>; i &lt;= K + W; i++) tmp += dp[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = K - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        tmp += dp[i + <span class="number">1</span>];</span><br><span class="line">        tmp -= dp[i + <span class="number">1</span> + W];</span><br><span class="line">        dp[i] = tmp / W;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 64.求1+2+...+n</title>
    <url>/2021/06/21/LeetCode/leetcode-64/</url>
    <content><![CDATA[<h3 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h3><ul>
<li>求 1+2+…+n ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。<span id="more"></span>
<h3 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: n = 3</span><br><span class="line">输出: 6</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: n = 9</span><br><span class="line">输出: 45</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>可以先思考通过求和公式 <code>n * (n + 1) &gt;&gt; 1</code> 但这种方式必须要用乘法，不然的话需要<code>if</code>来做判断，在偶数那里 <code> &gt;&gt; 1</code> ，所以这个思路会行不通。</p>
<p>通过循环来求和 <code>while(n) sum += (n--);</code> 但是会用到<code>while</code>可这已经很精简了，没有用到乘除法只是多了一个while，while又可以通过递归消掉。</p>
<ul>
<li>思考如何去掉while循环，这里要明确一点，在 <code>C/C++</code> 中<code>&amp;&amp;</code>和<code>||</code>操作并不是对两个操作数都去判断一下，<strong>而是当<code>&amp;&amp;</code>, <code>||</code>第一个操作数就已经满足条件的情况下不会再去判断第二个操作数了</strong>，利用这一点可以作为递归的边界判断。<br>  假设当前循环到了 $x$<ul>
<li><code>!x || (sum += x)</code> 表示当 $x$ 达到<strong>向下</strong>循环边界 0 时返回 <code>false</code>，这时递归停止</li>
<li><code>x &amp;&amp; （sum += x)</code> 表示当 $x$ 达到<strong>向下</strong>循环边界 0 时返回 <code>false</code>，递归停止</li>
<li><code>x ^ n</code> 表示当 $x$ 达到<strong>向上</strong>循环边界 n 时递归停止，但是这种方法需要另一个函数的配合</li>
</ul>
</li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><ul>
<li>3种</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sumNums</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    !n || (n += <span class="built_in">sumNums</span>(n - <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sumNums</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    n &amp;&amp; (n += <span class="built_in">sumNums</span>(n - <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">subSum</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    (x ^ n) &amp;&amp; (x += <span class="built_in">subSum</span>(x + <span class="number">1</span>, n));</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sumNums</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">subSum</span>(<span class="number">1</span>, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2020/06/02/Og8FAjvZ6pR2SKQ.png" alt="leetcode6-2_2.png"></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>mongoose API参考</title>
    <url>/2021/08/01/mongoose-API%E5%8F%82%E8%80%83/</url>
    <content><![CDATA[<h3 id="通用API"><a href="#通用API" class="headerlink" title="通用API"></a>通用API</h3><span id="more"></span>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">http_message</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mg_str</span> <span class="title">message</span>;</span> <span class="comment">/* Whole message: request line + headers + body */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mg_str</span> <span class="title">body</span>;</span>    <span class="comment">/* Message body. 0-length for requests with no body */</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* HTTP Request line (or HTTP response line) */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mg_str</span> <span class="title">method</span>;</span> <span class="comment">/* &quot;GET&quot; */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mg_str</span> <span class="title">uri</span>;</span>    <span class="comment">/* &quot;/my_file.html&quot; */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mg_str</span> <span class="title">proto</span>;</span>  <span class="comment">/* &quot;HTTP/1.1&quot; -- for both request and response */</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* For responses, code and response status message are set */</span></span><br><span class="line">  <span class="keyword">int</span> resp_code;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mg_str</span> <span class="title">resp_status_msg</span>;</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * Query-string part of the URI. For example, for HTTP request</span></span><br><span class="line"><span class="comment">   *    GET /foo/bar?param1=val1&amp;param2=val2</span></span><br><span class="line"><span class="comment">   *    |    uri    |     query_string     |</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * Note that question mark character doesn&#x27;t belong neither to the uri,</span></span><br><span class="line"><span class="comment">   * nor to the query_string</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mg_str</span> <span class="title">query_string</span>;</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Headers */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mg_str</span> <span class="title">header_names</span>[<span class="title">MG_MAX_HTTP_HEADERS</span>];</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mg_str</span> <span class="title">header_values</span>[<span class="title">MG_MAX_HTTP_HEADERS</span>];</span></span><br><span class="line">&#125;;<span class="comment">///HTTP消息</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">websocket_message</span> &#123;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> *data;</span><br><span class="line">  <span class="keyword">size_t</span> size;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> flags;</span><br><span class="line">&#125;;<span class="comment">///websocket消息</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mg_http_multipart_part</span> &#123;</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *file_name;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *var_name;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mg_str</span> <span class="title">data</span>;</span></span><br><span class="line">  <span class="keyword">int</span> status; <span class="comment">/* &lt;0 on error */</span></span><br><span class="line">  <span class="keyword">void</span> *user_data;</span><br><span class="line">&#125;;<span class="comment">///HTTP分包部分</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mg_ssi_call_ctx</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">http_message</span> *<span class="title">req</span>;</span> <span class="comment">/* The request being processed. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mg_str</span> <span class="title">file</span>;</span>       <span class="comment">/* Filesystem path of the file being processed. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mg_str</span> <span class="title">arg</span>;</span> <span class="comment">/* The argument passed to the tag: &lt;!-- call arg --&gt;. */</span></span><br><span class="line">&#125;;<span class="comment">///SSI调用上下文</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mg_set_protocol_http_websocket</span><span class="params">(struct mg_connection *nc)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mg_send_websocket_handshake</span><span class="params">(struct mg_connection *nc, <span class="keyword">const</span> <span class="keyword">char</span> *uri,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 <span class="keyword">const</span> <span class="keyword">char</span> *extra_headers)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mg_send_websocket_handshake2</span><span class="params">(struct mg_connection *nc, <span class="keyword">const</span> <span class="keyword">char</span> *path,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="keyword">const</span> <span class="keyword">char</span> *host, <span class="keyword">const</span> <span class="keyword">char</span> *protocol,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="keyword">const</span> <span class="keyword">char</span> *extra_headers)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mg_send_websocket_handshake3</span><span class="params">(struct mg_connection *nc, <span class="keyword">const</span> <span class="keyword">char</span> *path,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="keyword">const</span> <span class="keyword">char</span> *host, <span class="keyword">const</span> <span class="keyword">char</span> *protocol,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="keyword">const</span> <span class="keyword">char</span> *extra_headers, <span class="keyword">const</span> <span class="keyword">char</span> *user,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="keyword">const</span> <span class="keyword">char</span> *pass)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mg_send_websocket_handshake3v</span><span class="params">(struct mg_connection *nc,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   <span class="keyword">const</span> struct mg_str path,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   <span class="keyword">const</span> struct mg_str host,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   <span class="keyword">const</span> struct mg_str protocol,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   <span class="keyword">const</span> struct mg_str extra_headers,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   <span class="keyword">const</span> struct mg_str user,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   <span class="keyword">const</span> struct mg_str pass)</span></span>;</span><br><span class="line"><span class="function">struct mg_connection *<span class="title">mg_connect_ws</span><span class="params">(struct mg_mgr *mgr,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    MG_CB(<span class="keyword">mg_event_handler_t</span> event_handler,</span></span></span><br><span class="line"><span class="params"><span class="function">                                          <span class="keyword">void</span> *user_data),</span></span></span><br><span class="line"><span class="params"><span class="function">                                    <span class="keyword">const</span> <span class="keyword">char</span> *url, <span class="keyword">const</span> <span class="keyword">char</span> *protocol,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    <span class="keyword">const</span> <span class="keyword">char</span> *extra_headers)</span></span>;</span><br><span class="line"><span class="function">struct mg_connection *<span class="title">mg_connect_ws_opt</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    struct mg_mgr *mgr, MG_CB(<span class="keyword">mg_event_handler_t</span> ev_handler, <span class="keyword">void</span> *user_data),</span></span></span><br><span class="line"><span class="params"><span class="function">    struct mg_connect_opts opts, <span class="keyword">const</span> <span class="keyword">char</span> *url, <span class="keyword">const</span> <span class="keyword">char</span> *protocol,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> <span class="keyword">char</span> *extra_headers)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mg_send_websocket_frame</span><span class="params">(struct mg_connection *nc, <span class="keyword">int</span> op_and_flags,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="keyword">const</span> <span class="keyword">void</span> *data, <span class="keyword">size_t</span> data_len)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mg_send_websocket_framev</span><span class="params">(struct mg_connection *nc, <span class="keyword">int</span> op_and_flags,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="keyword">const</span> struct mg_str *strings, <span class="keyword">int</span> num_strings)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mg_printf_websocket_frame</span><span class="params">(struct mg_connection *nc, <span class="keyword">int</span> op_and_flags,</span></span></span><br><span class="line"><span class="params"><span class="function">                               <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mg_url_decode</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *src, <span class="keyword">int</span> src_len, <span class="keyword">char</span> *dst, <span class="keyword">int</span> dst_len,</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="keyword">int</span> is_form_url_encoded)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">mg_hash_md5_v</span><span class="params">(<span class="keyword">size_t</span> num_msgs, <span class="keyword">const</span> <span class="keyword">uint8_t</span> *msgs[],</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="keyword">const</span> <span class="keyword">size_t</span> *msg_lens, <span class="keyword">uint8_t</span> *digest)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">mg_hash_sha1_v</span><span class="params">(<span class="keyword">size_t</span> num_msgs, <span class="keyword">const</span> <span class="keyword">uint8_t</span> *msgs[],</span></span></span><br><span class="line"><span class="params"><span class="function">                           <span class="keyword">const</span> <span class="keyword">size_t</span> *msg_lens, <span class="keyword">uint8_t</span> *digest)</span></span>;</span><br></pre></td></tr></table></figure>



<h3 id="HTTP-Server端API"><a href="#HTTP-Server端API" class="headerlink" title="HTTP Server端API"></a>HTTP Server端API</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mg_parse_http</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">int</span> n, struct http_message *hm, <span class="keyword">int</span> is_req)</span></span>;</span><br><span class="line"><span class="comment">/**解析http消息，如果is_req=1 此消息是http请求，is_req=0 此消息是http回应</span></span><br><span class="line"><span class="comment"> *返回解析的字节数 如果http消息不完整则返回0 如果解析出错，则返回负数*/</span></span><br><span class="line"><span class="function">struct mg_str *<span class="title">mg_get_http_header</span><span class="params">(struct http_message *hm, <span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br><span class="line"><span class="comment">/**搜索并返回解析后的http消息hm中的表头名称，如果没有找到标头，则返回NULL</span></span><br><span class="line"><span class="comment"> *实例：struct mg_str *host_hdr = mg_get_http_header(hm, &quot;Host&quot;);*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mg_http_parse_header</span><span class="params">(struct mg_str *hdr, <span class="keyword">const</span> <span class="keyword">char</span> *var_name, <span class="keyword">char</span> *buf,</span></span></span><br><span class="line"><span class="params"><span class="function">                         <span class="keyword">size_t</span> buf_size)</span></span>;</span><br><span class="line"><span class="comment">/**解析http头hdr,查找变量var_name并将其值存储到buf中，如果没有找到变量，返回0否则返回非0。此函数用于解析cookies验证头等。如果成功则返回变量值的长度，如果buf缓冲区不够大，或者没有找到此变量则返回0</span></span><br><span class="line"><span class="comment">char user[20];</span></span><br><span class="line"><span class="comment">struct mg_str *hdr = mg_get_http_header(hm, &quot;Authorization&quot;);</span></span><br><span class="line"><span class="comment">mg_http_parse_header(hdr, &quot;username&quot;, user, sizeof(user));</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mg_get_http_basic_auth</span><span class="params">(struct http_message *hm, <span class="keyword">char</span> *user, <span class="keyword">size_t</span> user_len,</span></span></span><br><span class="line"><span class="params"><span class="function">                           <span class="keyword">char</span> *pass, <span class="keyword">size_t</span> pass_len)</span></span>;</span><br><span class="line"><span class="comment">/*获取并解析授权，如果没有找到授权头或者mg_parse_http_basic_auth解析结果头失败*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mg_parse_http_basic_auth</span><span class="params">(struct mg_str *hdr, <span class="keyword">char</span> *user, <span class="keyword">size_t</span> user_len,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="keyword">char</span> *pass, <span class="keyword">size_t</span> pass_len)</span></span>;</span><br><span class="line"><span class="comment">/*解析授权,如授权类型不是Basic或者出现其他错误(如用于base64编码的用户密码不对)基本头返回-1*/</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">mg_parse_multipart</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> buf_len, <span class="keyword">char</span> *var_name,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="keyword">size_t</span> var_name_len, <span class="keyword">char</span> *file_name,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="keyword">size_t</span> file_name_len, <span class="keyword">const</span> <span class="keyword">char</span> **chunk,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="keyword">size_t</span> *chunk_len)</span></span>;</span><br><span class="line"><span class="comment">/*解析包含多部分表单数据库的缓冲区buf,buf_len,将块名存储在var_name,var_name_len缓冲区中。如果块是上传文件，那么file_name,file_name_len将会被一个上传的文件名填充。chunk,chunk_len指向块数据。返回要跳到下一个块的字节数，如果没有更多块则返回0*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mg_get_http_var</span><span class="params">(<span class="keyword">const</span> struct mg_str *buf, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">char</span> *dst,</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="keyword">size_t</span> dst_len)</span></span>;</span><br><span class="line"><span class="comment">/*获取Http表单变量。从buf获取变量名，到指定dst指定长度dst_len的缓冲区。目的地址总是0终止，返回获取到的变量的长度，如果没有找到变量，则返回0.buf必须是有效的url编码缓冲区。如果dst长度太小或者发生错误返回负数*/</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//此结构定义了mg_serve_http()的工作方式，最佳是设置需要的，其余为NULL</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mg_serve_http_opts</span> &#123;</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *document_root;<span class="comment">///web根目录路径</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *index_files;<span class="comment">///索引文件列表，默认是&quot;&quot;</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  per_directory_auth_file =NULL表示禁用身份验证</span></span><br><span class="line"><span class="comment">  per_directory_auth_file =&quot;.htpasswd&quot; 要使用身份认证来保护目录，然后在任何目录创建使用                                 digest认证的.htpasswd文件。使用mongoose web服务器二进制文件或                             者Apache的htpasswd实例创建/操作密码文件</span></span><br><span class="line"><span class="comment">                             确保auth_domain是一个有效的域</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *per_directory_auth_file;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *auth_domain;<span class="comment">//授权域。即web服务器的域名</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">      global_auth_file = NULL 禁用身份认证</span></span><br><span class="line"><span class="comment">      通常只保护document_root根目录选定的目录。如果对web服务器的所有访问都必须经过身份验证，       不管URI是什么，将此选项设置为密码文件的路径。此文件的格式与.htpasswd的格式一样，并把此        文件放在document_root根目录之外，以防他人获取到此文件</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *global_auth_file;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *enable_directory_listing;<span class="comment">//设置为&quot;no&quot;禁用目录列表，默认启用</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *ssi_pattern;<span class="comment">///ssi匹配模式  源码有详细介绍</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *ip_acl;<span class="comment">///ip_acl=NULL表示所有IP都可链接</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> MG_ENABLE_HTTP_URL_REWRITES</span></span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">char</span> *url_rewrites;/源码有详细介绍</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *dav_document_root;<span class="comment">///DAV的根目录,dav_document_root=NULL 则DAV请求失败</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *dav_auth_file;<span class="comment">//DAV密码文件，dav_auth_file=NULL 则DAV请求失败 dav_auth_file=&quot;-&quot; 禁用DAV鉴权</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *hidden_file_pattern;<span class="comment">///文件隐藏的Glob模式</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *cgi_file_pattern;<span class="comment">///cgi_file_pattern != NULL 则使能cgi，即此目录下满足 **.cgi$|**.php$&quot;都视为cgi文件</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *cgi_interpreter;<span class="comment">///如果不是NULL，请忽略CGI脚本hashbang并使用这个解释器</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *custom_mime_types;</span><br><span class="line"><span class="comment">/*Comma-separated list of Content-Type overrides for path suffixes,&quot;.txt=text/plain; charset=utf-8,.c=text/plain&quot;e.g.*/</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *extra_headers;<span class="comment">///添加到每个http相应的额外的header,要启用CORS，请将此设置为&quot;Access-Control-Allow-Origin: *&quot;。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mg_serve_http</span><span class="params">(struct mg_connection *nc, struct http_message *hm,</span></span></span><br><span class="line"><span class="params"><span class="function">                   struct mg_serve_http_opts opts)</span></span>;</span><br><span class="line"><span class="comment">/*根据opts的内容，提供特定的http请求*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mg_http_serve_file</span><span class="params">(struct mg_connection *nc, struct http_message *hm,</span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> struct mg_str mime_type,</span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="keyword">const</span> struct mg_str extra_headers)</span></span>;</span><br><span class="line"><span class="comment">/*提供具有给定MIME类型和可选extra_headers头的特定文件*/</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> struct <span class="title">mg_str</span> <span class="params">(*mg_fu_fname_fn)</span><span class="params">(struct mg_connection *nc,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        struct mg_str fname)</span></span>;<span class="comment">///mg_file_upload_handler()的回调函数原型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mg_file_upload_handler</span><span class="params">(struct mg_connection *nc, <span class="keyword">int</span> ev, <span class="keyword">void</span> *ev_data,</span></span></span><br><span class="line"><span class="params"><span class="function">                            mg_fu_fname_fn local_name_fn</span></span></span><br><span class="line"><span class="params"><span class="function">                                MG_UD_ARG(<span class="keyword">void</span> *user_data))</span></span>;</span><br><span class="line"><span class="comment">/*文件上传处理程序。这个处理程序可以用最少的代码实现文件上传.此程序处理MG_EV_HTTPPART事件并保存文件数据到本地。local_name_fn将以客户端提供的名字调用并以期望的本地文件名称打开。如果返回NULL将终止文件上传(客户端得到403)，如果返回不是NULL,返回的字符串必须是堆分配的，且调用方需要释放这些字符串。异常情况：返回完全相同的字符串，</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mg_register_http_endpoint</span><span class="params">(struct mg_connection *nc, <span class="keyword">const</span> <span class="keyword">char</span> *uri_path,</span></span></span><br><span class="line"><span class="params"><span class="function">                               MG_CB(<span class="keyword">mg_event_handler_t</span> handler,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     <span class="keyword">void</span> *user_data))</span></span>;</span><br><span class="line"><span class="comment">/*为nc注册回调函数，如果注册了回调函数，其会被调用欧冠，而不是调用mg_bind()中提供的回调函数*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mg_http_endpoint_opts</span> &#123;</span></span><br><span class="line">  <span class="keyword">void</span> *user_data;</span><br><span class="line">  <span class="comment">/*授权域 (realm) */</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *auth_domain;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *auth_file;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mg_register_http_endpoint_opt</span><span class="params">(struct mg_connection *nc,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   <span class="keyword">const</span> <span class="keyword">char</span> *uri_path,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   <span class="keyword">mg_event_handler_t</span> handler,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   struct mg_http_endpoint_opts opts)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mg_http_check_digest_auth</span><span class="params">(struct http_message *hm, <span class="keyword">const</span> <span class="keyword">char</span> *auth_domain,</span></span></span><br><span class="line"><span class="params"><span class="function">                              FILE *fp)</span></span>;</span><br><span class="line"><span class="comment">/*根据打开的密码文件验证HTTP请求。如果经过身份验证，返回1，否则返回0*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mg_check_digest_auth</span><span class="params">(struct mg_str method, struct mg_str uri,</span></span></span><br><span class="line"><span class="params"><span class="function">                         struct mg_str username, struct mg_str cnonce,</span></span></span><br><span class="line"><span class="params"><span class="function">                         struct mg_str response, struct mg_str qop,</span></span></span><br><span class="line"><span class="params"><span class="function">                         struct mg_str nc, struct mg_str nonce,</span></span></span><br><span class="line"><span class="params"><span class="function">                         struct mg_str auth_domain, FILE *fp)</span></span>;</span><br><span class="line"><span class="comment">/*对打开的密码文件验证给定的响应参数。如果经过身份验证，返回1，否则返回0。</span></span><br><span class="line"><span class="comment">由 mg_http_check_digest_auth().调用</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mg_send_http_chunk</span><span class="params">(struct mg_connection *nc, <span class="keyword">const</span> <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> len)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">使用组块HTTP编码向客户端发送大小为len的缓冲区buf.这个函数首先将  发送缓冲区大小(16进制)+换行符+缓冲区+换行符发出。例如，mg_send_http_chunk(nc，“foo”，3)将把 &quot;3\r\nfoo\r\n&quot;字符串追加到nc-&gt;send_mbuf输出IO缓冲区</span></span><br><span class="line"><span class="comment">HTTP头“传输编码:块化”应该在使用此函数之前发送</span></span><br><span class="line"><span class="comment">不要忘记在响应结束时发送一个空块，告诉客户端所有内容都已发送</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mg_printf_http_chunk</span><span class="params">(struct mg_connection *nc, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span></span>;</span><br><span class="line"><span class="comment">/*发送一个printf格式的HTTP块。功能类似于mg_send_http_chunk()。*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mg_send_response_line</span><span class="params">(struct mg_connection *nc, <span class="keyword">int</span> status_code,</span></span></span><br><span class="line"><span class="params"><span class="function">                           <span class="keyword">const</span> <span class="keyword">char</span> *extra_headers)</span></span>;</span><br><span class="line"><span class="comment">/*发送响应状态行。如果extra_headers不是NULL，那么extra_headers也会在响应行之后发送。extra_headers不能以新行结束*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mg_http_send_error</span><span class="params">(struct mg_connection *nc, <span class="keyword">int</span> code, <span class="keyword">const</span> <span class="keyword">char</span> *reason)</span></span>;</span><br><span class="line"><span class="comment">/*发送一个错误的回应。如果原因为空，消息将从错误代码中推断出来(如果支持的话)*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mg_http_send_redirect</span><span class="params">(struct mg_connection *nc, <span class="keyword">int</span> status_code,</span></span></span><br><span class="line"><span class="params"><span class="function">                           <span class="keyword">const</span> struct mg_str location,</span></span></span><br><span class="line"><span class="params"><span class="function">                           <span class="keyword">const</span> struct mg_str extra_headers)</span></span>;</span><br><span class="line"><span class="comment">/*发送一个重定向响应。status_code应该是301或302，位置指向新位置。如果extra_headers不是空的，那么extra_headers也会在响应行之后发送。extra_headers不能以新行结束。*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mg_send_head</span><span class="params">(struct mg_connection *n, <span class="keyword">int</span> status_code,</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="keyword">int64_t</span> content_length, <span class="keyword">const</span> <span class="keyword">char</span> *extra_headers)</span></span>;</span><br><span class="line"><span class="comment">/*发送响应行和标题。这个函数用status_code发送响应行，并自动发送一个标题:&quot;Content-Length&quot;或 &quot;Transfer-Encoding&quot;。如果content_length为负，则发送“Transfer-Encoding: chunked”报头，否则发送“Content-Length”报头。如果转换编码被分割，那么消息体必须使用mg_send_http_chunk()或mg_printf_http_chunk()函数发送。否则，必须使用mg_send()或mg_printf()。额外的标题可以通过extra_headers设置。注意，extra_headers不能被一个新的行终止*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mg_printf_html_escape</span><span class="params">(struct mg_connection *nc, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span></span>;</span><br><span class="line"><span class="comment">/*发送一个打印格式的HTTP块，转义HTML标记*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mg_http_reverse_proxy</span><span class="params">(struct mg_connection *nc,</span></span></span><br><span class="line"><span class="params"><span class="function">                           <span class="keyword">const</span> struct http_message *hm, struct mg_str mount,</span></span></span><br><span class="line"><span class="params"><span class="function">                           struct mg_str upstream)</span></span>;</span><br><span class="line"><span class="comment">/*将给定的请求代理给给定的上游http服务器.挂载中的路径前缀将被剥离到上游服务器请求的路径，例如如果挂载为/api，上游为 http://localhost:8001/foo 那么向/api传入的请求将传入到 http://localhost:8001/foo/bar*/</span></span><br></pre></td></tr></table></figure>



<h3 id="HTTP-Client端API"><a href="#HTTP-Client端API" class="headerlink" title="HTTP Client端API"></a>HTTP Client端API</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">struct mg_connection *<span class="title">mg_connect_http</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    struct mg_mgr *mgr,</span></span></span><br><span class="line"><span class="params"><span class="function">    MG_CB(<span class="keyword">mg_event_handler_t</span> event_handler, <span class="keyword">void</span> *user_data), <span class="keyword">const</span> <span class="keyword">char</span> *url,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> <span class="keyword">char</span> *extra_headers, <span class="keyword">const</span> <span class="keyword">char</span> *post_data)</span></span>;</span><br><span class="line"><span class="comment">/*创建出站HTTP连接的助手函数</span></span><br><span class="line"><span class="comment">url是要获取的url。它必须被正确地url编码，例如没有空格，等等.默认情况下，mg_connect_http()发送连接和主机头</span></span><br><span class="line"><span class="comment">extra_headers是一个额外的HTTP头:&quot;User-Agent: my-app\r\n&quot;</span></span><br><span class="line"><span class="comment">如果post_data为空，则创建一个GET请求。否则，将使用指定的POST数据创建POST请求。</span></span><br><span class="line"><span class="comment">注意，如果要提交的数据是表单提交，那么应该相应地设置Content-Type报头(参见下面的示例)。</span></span><br><span class="line"><span class="comment">nc1 = mg_connect_http(mgr, ev_handler_1, &quot;http://www.google.com&amp;quot;, NULL,</span></span><br><span class="line"><span class="comment">                        NULL);</span></span><br><span class="line"><span class="comment">nc2 = mg_connect_http(mgr, ev_handler_1, &quot;https://github.com&amp;quot;, NULL, NULL);</span></span><br><span class="line"><span class="comment">nc3 = mg_connect_http(</span></span><br><span class="line"><span class="comment">      mgr, ev_handler_1, &quot;my_server:8000/form_submit/&quot;,</span></span><br><span class="line"><span class="comment">      &quot;Content-Type: application/x-www-form-urlencoded\r\n&quot;,</span></span><br><span class="line"><span class="comment">      &quot;var_1=value_1&amp;var_2=value_2&quot;);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">struct mg_connection *<span class="title">mg_connect_http_opt</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    struct mg_mgr *mgr, MG_CB(<span class="keyword">mg_event_handler_t</span> ev_handler, <span class="keyword">void</span> *user_data),</span></span></span><br><span class="line"><span class="params"><span class="function">    struct mg_connect_opts opts, <span class="keyword">const</span> <span class="keyword">char</span> *url, <span class="keyword">const</span> <span class="keyword">char</span> *extra_headers,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> <span class="keyword">char</span> *post_data)</span></span>;</span><br><span class="line"><span class="comment">/*创建出站HTTP连接的助手函数.与mg_connect_http基本相同，但允许提供额外的参数(例如SSL参数)*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mg_http_create_digest_auth_header</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">size_t</span> buf_len,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      <span class="keyword">const</span> <span class="keyword">char</span> *method, <span class="keyword">const</span> <span class="keyword">char</span> *uri,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      <span class="keyword">const</span> <span class="keyword">char</span> *auth_domain, <span class="keyword">const</span> <span class="keyword">char</span> *user,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      <span class="keyword">const</span> <span class="keyword">char</span> *passwd)</span></span>;</span><br><span class="line"><span class="comment">/*为客户机请求创建摘要身份验证头*/</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux网络编程</category>
      </categories>
      <tags>
        <tag>mongoose</tag>
      </tags>
  </entry>
  <entry>
    <title>Git</title>
    <url>/2021/08/08/Git/</url>
    <content><![CDATA[<h2 id="前言-（转）"><a href="#前言-（转）" class="headerlink" title="前言 （转）"></a>前言 （转）</h2><p>因为工作需求，最近又重新温习了一下Git操作，遂总结了一篇Git常用操作指南，方便日后学习查阅，本博客精简提炼了在开发过程中Git经常用到的核心命令，主要参考了《<a href="https://www.liaoxuefeng.com/wiki/896043488029600">廖雪峰老师的Git教程</a>》，希望对大家学习使用Git能带来帮助。</p>
<span id="more"></span>

<h2 id="Git简介"><a href="#Git简介" class="headerlink" title="Git简介"></a>Git简介</h2><p>Git是Linux之父Linus的第二个伟大的作品，它最早是在Linux上开发的，被用来管理Linux核心的源代码。后来慢慢地有人将其移植到了Unix、Windows、Max OS等操作系统中。</p>
<p>Git是一个分布式的版本控制系统，与集中式的版本控制系统不同的是，每个人都工作在通过克隆建立的本地版本库中。也就是说每个人都拥有一个完整的版本库，查看提交日志、提交、创建里程碑和分支、合并分支、回退等所有操作都直接在本地完成而不需要网络连接。</p>
<p>对于Git仓库来说，每个人都有一个独立完整的仓库，所谓的远程仓库或是服务器仓库其实也是一个仓库，只不过这台主机24小时运行，它是一个稳定的仓库，供他人克隆、推送，也从服务器仓库中拉取别人的提交。</p>
<p>Git是目前世界上最先进的分布式版本控制系统。</p>
<h2 id="安装之后第一步"><a href="#安装之后第一步" class="headerlink" title="安装之后第一步"></a>安装之后第一步</h2><p>安装完成后，还需要最后一步设置，在命令行输入：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> git config -<span class="literal">-global</span> user.name <span class="string">&quot;Your Name&quot;</span></span><br><span class="line"><span class="variable">$</span> git config -<span class="literal">-global</span> user.email <span class="string">&quot;email@example.com&quot;</span></span><br></pre></td></tr></table></figure>

<p>因为Git是分布式版本控制系统，所以，每个机器都必须配置用户信息：你的名字和Email地址。</p>
<p>注意<code>git config</code>命令的<code>--global</code>参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。</p>
<h2 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h2><h3 id="本地仓库"><a href="#本地仓库" class="headerlink" title="本地仓库"></a>本地仓库</h3><p>版本库又名仓库，英文名<strong>repository</strong>，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。</p>
<p>所以，创建一个版本库非常简单，首先，选择一个合适的地方，创建一个空目录：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> mkdir learngit</span><br><span class="line"><span class="variable">$</span> <span class="built_in">cd</span> learngit</span><br><span class="line"><span class="variable">$</span> <span class="built_in">pwd</span></span><br><span class="line">Path</span><br><span class="line">----</span><br><span class="line">D:\Blog\tmp\learngit</span><br></pre></td></tr></table></figure>

<p>第二步，通过<code>git init</code>命令把这个目录变成Git可以管理的仓库：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> git init</span><br><span class="line">Initialized empty Git repository <span class="keyword">in</span> D:/Blog/tmp/learngit/.git/</span><br></pre></td></tr></table></figure>

<h3 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h3><h4 id="创建SSH-Key"><a href="#创建SSH-Key" class="headerlink" title="创建SSH Key"></a>创建SSH Key</h4><p>Git支持多种协议，包括<code>https</code>，但通过<code>ssh</code>支持的原生<code>git</code>协议速度最快。由于本地Git仓库和GitHub仓库之间的传输是通过SSH加密的，所以，需要在关联远程仓库前需要配置<code>SSH Key</code>至Github设置中，这样远程仓库才允许本机对远程仓库的拉去/推送操作。</p>
<p>打开<code>Shell</code>，进入到”<code>~/.ssh</code>“目录下，运行”<code>ls</code>“命令看看这个目录下有没有<code>id_rsa</code>和<code>id_rsa.pub</code>这两个文件，如果已经有了，可直接跳到下一步。</p>
<p>如果没有，则执行：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> ssh<span class="literal">-keygen</span> <span class="literal">-t</span> rsa <span class="literal">-C</span> <span class="string">&quot;youremail@example.com&quot;</span></span><br></pre></td></tr></table></figure>

<p>一路回车即可。执行命令后，我们再进入到”<code>~/.ssh</code>“目录下，运行”<code>ls</code>“命令，可以看到里面有<code>id_rsa</code>和<code>id_rsa.pub</code>两个文件，这两个就是SSH Key的秘钥对，<code>id_rsa</code>是私钥，不能泄露出去，<code>id_rsa.pub</code>是公钥，可以放心地告诉任何人。</p>
<p><img src="http://pic.guoyaohua.com/image/git/1563105584864.png" alt="1563105584864"></p>
<p>打开“Account settings”，“SSH Keys”页面，然后，点“New SSH Key”，填上任意Title，在Key文本框里粘贴<code>id_rsa.pub</code>文件的内容（Win 10 下可使用”<code>type ~/.ssh/id_rsa.pub</code>“命令查看公钥文件内容）：</p>
<p><img src="http://pic.guoyaohua.com/image/git/1563105973152.png" alt="1563105973152"></p>
<p>点击“Add SSH Key”之后，就可以看到你的公钥已经加入到了你的Github仓库配置中。</p>
<p><img src="http://pic.guoyaohua.com/image/git/1563106045201.png" alt="1563106045201"></p>
<h4 id="添加远程库"><a href="#添加远程库" class="headerlink" title="添加远程库"></a>添加远程库</h4><p>首先，登陆GitHub，然后，在右上角找到“Create a new repo”按钮，创建一个新的仓库：</p>
<p><img src="http://pic.guoyaohua.com/image/git/1563103995786.png" alt="1563103995786"></p>
<p>在Repository name填入<code>learngit</code>，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库：</p>
<p><img src="http://pic.guoyaohua.com/image/git/1563104100618.png" alt="1563104100618"></p>
<p>这样就成功创建了一个空白的远程仓库，那么如何将这个远程仓库与本地仓库进行关联呢？</p>
<p>我们根据Git所给出的提示可知，可以在本地创建一个新仓库对远程仓库进行关联，也可以对本地已有仓库进行关联。</p>
<h5 id="关联新仓库"><a href="#关联新仓库" class="headerlink" title="关联新仓库"></a>关联新仓库</h5><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;# learngit&quot;</span> &gt;&gt; README.md</span><br><span class="line">git init</span><br><span class="line">git add README.md</span><br><span class="line">git commit <span class="literal">-m</span> <span class="string">&quot;first commit&quot;</span></span><br><span class="line">git remote add origin git@github.com:guoyaohua/learngit.git</span><br><span class="line">git push <span class="literal">-u</span> origin master</span><br></pre></td></tr></table></figure>

<h5 id="关联已有仓库"><a href="#关联已有仓库" class="headerlink" title="关联已有仓库"></a>关联已有仓库</h5><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">git remote add origin git@github.com:guoyaohua/learngit.git</span><br><span class="line">git push <span class="literal">-u</span> origin master</span><br></pre></td></tr></table></figure>

<p>我们可以使用上文在本地初始化的“learngit”仓库。<strong>（注意：本地仓库和远程仓库可以不同名，本文只是为了写教程设置为相同名称。）</strong></p>
<p><img src="http://pic.guoyaohua.com/image/git/1563104810075.png" alt="1563104810075"></p>
<p>我们再刷新下<code>Github Code</code>界面，发现新加入的<code>README.md</code>文件已经推送到了远程仓库中。</p>
<p><img src="http://pic.guoyaohua.com/image/git/1563106284174.png" alt="1563106284174"></p>
<h2 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h2><h3 id="工作区和暂存区"><a href="#工作区和暂存区" class="headerlink" title="工作区和暂存区"></a>工作区和暂存区</h3><h4 id="工作区（Working-Directory）"><a href="#工作区（Working-Directory）" class="headerlink" title="工作区（Working Directory）"></a>工作区（Working Directory）</h4><p>就是你在电脑里能看到的目录，比如我们刚刚创建的<code>learngit</code>文件夹就是一个工作区：</p>
<p><img src="http://pic.guoyaohua.com/image/git/1563106681604.png" alt="1563106681604"></p>
<h4 id="版本库（Repository）"><a href="#版本库（Repository）" class="headerlink" title="版本库（Repository）"></a>版本库（Repository）</h4><p>工作区有一个隐藏目录<code>.git</code>，这个不算工作区，而是Git的版本库。</p>
<p>Git的版本库里存了很多东西，其中最重要的就是称为<strong>Stage</strong>（或者叫<strong>Index</strong>）的<strong>暂存区</strong>，还有Git为我们自动创建的第一个分支<code>master</code>，以及指向<code>master</code>的一个指针叫<code>HEAD</code>。</p>
<p><img src="http://pic.guoyaohua.com/image/git/Repository.jpg" alt="Repository"></p>
<p>分支和<code>HEAD</code>的概念本文后面再详细说明。</p>
<p>我们把文件往Git版本库里添加的时候，是分两步执行的：</p>
<p>第一步是用<code>git add</code>把文件添加进去，实际上就是把文件修改添加到<strong>暂存区</strong>；</p>
<p>第二步是用<code>git commit</code>提交更改，实际上就是把暂存区的所有内容提交到当前分支。</p>
<p>因为我们创建Git版本库时，Git自动为我们创建了唯一一个<code>master</code>分支，所以现在，<code>git commit</code>就是往<code>master</code>分支上提交更改。</p>
<p>你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。</p>
<p>使用<code>git status</code>命令可以查看当前仓库的状态。</p>
<h3 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h3><p>Git版本控制可以理解为，我们再编写代码的过程中，会对code进行多次修改，每当你觉得文件修改到一定程度的时候，就可以“保存一个快照”，这个快照在Git中被称为<code>commit</code>。一旦你把文件改乱了，或者误删了文件，还可以从最近的一个<code>commit</code>恢复，然后继续工作，而不是把几个月的工作成果全部丢失。</p>
<p>在实际工作中，我们用<code>git log</code>命令查看我们提交的历史记录：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> git log</span><br><span class="line">commit <span class="number">1094</span>adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -&gt; master)</span><br><span class="line">Author: Yaohua Guo &lt;guo.yaohua@foxmail.com&gt;</span><br><span class="line">Date:   Fri May <span class="number">18</span> <span class="number">21</span>:<span class="number">06</span>:<span class="number">15</span> <span class="number">2018</span> +<span class="number">0800</span></span><br><span class="line"></span><br><span class="line">    append GPL</span><br><span class="line"></span><br><span class="line">commit e475afc93c209a690c39c13a46716e8fa000c366</span><br><span class="line">Author: Yaohua Guo &lt;guo.yaohua@foxmail.com&gt;</span><br><span class="line">Date:   Fri May <span class="number">18</span> <span class="number">21</span>:<span class="number">03</span>:<span class="number">36</span> <span class="number">2018</span> +<span class="number">0800</span></span><br><span class="line"></span><br><span class="line">    add distributed</span><br><span class="line"></span><br><span class="line">commit eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0</span><br><span class="line">Author: Yaohua Guo &lt;guo.yaohua@foxmail.com&gt;</span><br><span class="line">Date:   Fri May <span class="number">18</span> <span class="number">20</span>:<span class="number">59</span>:<span class="number">18</span> <span class="number">2018</span> +<span class="number">0800</span></span><br><span class="line"></span><br><span class="line">    wrote a readme file</span><br></pre></td></tr></table></figure>

<p>Git中，commit id是一个使用SHA1计算出来的一个非常大的数字，用十六进制表示，commit后面的那一串十六进制数字就是每一次提交的版本号，我们可以通过<code>git log</code>命令看到每次提交的版本号、用户名、日期以及版本描述等信息。</p>
<p>我们可以使用<code>git reset</code>命令进行版本回退操作。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> git reset -<span class="literal">-hard</span> HEAD^</span><br></pre></td></tr></table></figure>

<p>在Git中，用HEAD表示当前版本，上一个版本就是HEAD^ ，上上一个版本就是HEAD^^ ，以此类推，如果需要回退几十个版本，写几十个^容易数不过来，所以可以写，例如回退30个版本为：HEAD~30。</p>
<p>如果回退完版本又后悔了，想恢复，也是可以的，使用如下即可：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> git reset -<span class="literal">-hard</span> commit_id </span><br></pre></td></tr></table></figure>

<p>不过当我们执行<code>git reset</code>进行版本回退之后，之前最新的版本号无法通过<code>git log</code>查询到，此时需要使用<code>git reflog</code>命令查询Git的操作记录，我们可以从该记录中找到之前的commit id信息。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> git reflog</span><br><span class="line">e475afc HEAD<span class="selector-tag">@</span>&#123;<span class="number">1</span>&#125;: reset: moving to HEAD^</span><br><span class="line"><span class="number">1094</span>adb (HEAD -&gt; master) HEAD<span class="selector-tag">@</span>&#123;<span class="number">2</span>&#125;: commit: append GPL</span><br><span class="line">e475afc HEAD<span class="selector-tag">@</span>&#123;<span class="number">3</span>&#125;: commit: add distributed</span><br><span class="line">eaadf4e HEAD<span class="selector-tag">@</span>&#123;<span class="number">4</span>&#125;: commit (initial): wrote a readme file</span><br></pre></td></tr></table></figure>

<p>在Git中，版本回退速度非常快，因为Git在内部有个指向当前版本的HEAD指针，当你回退版本的时候，Git仅仅是把HEAD从指向回退的版本，然后顺便刷新工作区文件。</p>
<h4 id="重置命令"><a href="#重置命令" class="headerlink" title="重置命令"></a>重置命令</h4><p>重置命令的作用是将当前的分支重设（reset）到指定的<code>&lt;commit&gt;</code>或者<code>HEAD</code>（默认是HEAD，即最新的一次提交），并且根据[mode]有可能更新Index和Working directory（默认是mixed）。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> git reset [--<span class="type">hard</span>|<span class="type">soft</span>|<span class="type">mixed</span>|<span class="type">merge</span>|<span class="type">keep</span>] [<span class="type">commit</span>|<span class="type">HEAD</span>]</span><br></pre></td></tr></table></figure>

<ol>
<li>–hard：<strong>重设“暂存区”和“工作区”</strong>，从<code>&lt;commit&gt;</code>以来在工作区中的任何改变都被丢弃，并把HEAD指向<code>&lt;commit&gt;</code>。<strong>（彻底回退到某个版本，本地的源码也会变为上一个版本的内容。）</strong></li>
<li>–soft：<strong>“工作区”中的内容不作任何改变，HEAD指向<code>&lt;commit&gt;</code>，自从<code>&lt;commit&gt;</code>以来的所有改变都会回退到“暂存区”中，显示在<code>git status</code>的*“Changes to be committed”*中。（回退到某个版本，只回退了commit的信息。如果还要提交，直接commit即可。）</strong></li>
<li>–mixed：<strong>仅重设“暂存区”，并把HEAD指向<code>&lt;commit&gt;</code>，但是不重设“工作区”，本地文件修改不受影响。</strong>这个模式是默认模式，即当不显示告知<code>git reset</code>模式时，会使用mixed模式。这个模式的效果是，工作区中文件的修改都会被保留，不会丢弃，但是也不会被标记成“<em>Changes to be committed</em>”，但是会提示文件未被更新。<strong>（回退到某个版本，只保留源码，回退commit和index信息）</strong></li>
</ol>
<h5 id="文件粒度操作"><a href="#文件粒度操作" class="headerlink" title="文件粒度操作"></a>文件粒度操作</h5><p>需要注意的是在<code>mixed</code>模式下进行<code>reset</code>操作时可以是全局性重置，也可以是文件粒度重置，区别在于二者作用域不同，文件粒度只会使对应文件的暂存区状态变为指定commit时该文件的暂存区状态，并且不会改变版本库状态，即HEAD指针不会改变，我们看一下效果。</p>
<p>首先我们新建两个文件进行两次提交，可以看到目前HEAD指向最新一次提交“text2”。</p>
<p><img src="http://pic.guoyaohua.com/image/git/1563611168654.png" alt="1563611168654"></p>
<p>我们对“file1.txt”进行reset操作，令其重置为“text1”状态。</p>
<p><img src="http://pic.guoyaohua.com/image/git/1563611993505.png" alt="1563611993505"></p>
<p>并且我们通过git log命令可发现，此时HEAD指针并没有改变，还是指向最新一次提交“Text 2”，可知文件粒度的<code>reset --mixed</code>不改变版本库HEAD指针状态。</p>
<p><img src="http://pic.guoyaohua.com/image/git/1563612094551.png" alt="1563612094551"></p>
<p>对于soft和hard模式则无法进行文件粒度操作。</p>
<p><img src="http://pic.guoyaohua.com/image/git/1563609363728.png" alt="1563609363728"></p>
<h4 id="Reset-常用示例"><a href="#Reset-常用示例" class="headerlink" title="Reset 常用示例"></a>Reset 常用示例</h4><ol>
<li><p>回退add操作</p>
 <figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> git add test</span><br><span class="line"><span class="variable">$</span> git reset HEAD test  </span><br><span class="line"><span class="comment"># HEAD指的是当前指向的版本号，可以将HEAD还成任意想回退的版本号</span></span><br></pre></td></tr></table></figure>

<p> 可以将test从“已暂存”状态（Index区）回滚到指定Commit时暂存区的状态。</p>
</li>
<li><p>回退最后一次提交</p>
 <figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> git add test</span><br><span class="line"><span class="variable">$</span> git commit <span class="literal">-m</span> <span class="string">&quot;Add test&quot;</span></span><br><span class="line"><span class="variable">$</span> git reset -<span class="literal">-soft</span> HEAD^</span><br></pre></td></tr></table></figure>

<p> 可以将test从“已提交”状态变为“已暂存”状态。</p>
</li>
<li><p>回退最近几次提交，并把这几次提交放到新分支上</p>
 <figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> git branch topic <span class="comment"># 已当前分支为基础，新建分支topic</span></span><br><span class="line"><span class="variable">$</span> git reset -<span class="literal">-hard</span> HEAD~<span class="number">2</span> <span class="comment"># 在当前分支上回滚提交</span></span><br><span class="line"><span class="variable">$</span> git checkout topic</span><br></pre></td></tr></table></figure>

<p> 通过临时分支来保留提交，然后在当前分支上做硬回滚。</p>
</li>
<li><p>将本地的状态回退到和远程一样</p>
 <figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> git reset -<span class="literal">-hard</span> origin/devlop</span><br></pre></td></tr></table></figure></li>
<li><p>回退到某个版本提交</p>
 <figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> git reset <span class="number">497</span>e350</span><br></pre></td></tr></table></figure>

<p> 当前HEAD会指向“497e350”，暂存区中的状态会恢复到提交“497e350”时暂存区的状态。</p>
</li>
</ol>
<h3 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h3><p>当我们因为一些原因想要丢弃工作区某些文件修改时，可以使用“<code>git checkout -- &lt;file&gt;</code>”命令，该命令仅会恢复工作区文件状态，不会对版本库有任何改动。</p>
<p><img src="http://pic.guoyaohua.com/image/git/1563613938574.png" alt="1563613938574"></p>
<p>命令<code>git checkout -- file1.txt</code>意思就是，把<code>file1.txt</code>文件在工作区的修改全部撤销，这里有两种情况：</p>
<ul>
<li>一种是<code>file1.txt</code>自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</li>
<li>一种是<code>file1.txt</code>已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</li>
</ul>
<p>总之，就是让这个文件回到最近一次<code>git commit</code>或<code>git add</code>时的状态。</p>
<h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><p>在Git中，删除也是一个修改操作，我们实战一下，先添加一个新文件<code>test.txt</code>到Git并且提交：</p>
<p>一般情况下，你通常直接在文件管理器中把没用的文件删了，或者用<code>rm</code>命令删了：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> <span class="built_in">rm</span> test.txt</span><br></pre></td></tr></table></figure>

<p>这个时候，Git知道你删除了文件，因此，工作区和版本库就不一致了，<code>git status</code>命令会立刻告诉你哪些文件被删除了：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">&quot;git add/rm &lt;file&gt;...&quot;</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">&quot;git checkout -- &lt;file&gt;...&quot;</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"></span><br><span class="line">	deleted:    test.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">&quot;git add&quot;</span> and/or <span class="string">&quot;git commit -a&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>现在你有两个选择，一是确实要从版本库中删除该文件，那就用命令<code>git rm</code>删掉，并且<code>git commit</code>：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> git <span class="built_in">rm</span> test.txt</span><br><span class="line"><span class="built_in">rm</span> <span class="string">&#x27;test.txt&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$</span> git commit <span class="literal">-m</span> <span class="string">&quot;remove test.txt&quot;</span></span><br><span class="line">[<span class="type">master</span> <span class="type">d46f35e</span>] remove test.txt</span><br><span class="line"> <span class="number">1</span> file changed, <span class="number">1</span> deletion(-)</span><br><span class="line"> delete mode <span class="number">100644</span> test.txt</span><br></pre></td></tr></table></figure>

<p>现在，文件就从版本库中被删除了。</p>
<blockquote>
<p>提示：先手动删除文件，然后使用<code>git rm &lt;file&gt;</code>和<code>git add &lt;file&gt;</code>效果是一样的。</p>
</blockquote>
<p>另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> git checkout -- test.txt</span><br></pre></td></tr></table></figure>

<p><code>git checkout</code>其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</p>
<blockquote>
<p>注意：从来没有被添加到版本库就被删除的文件，是无法恢复的！</p>
</blockquote>
<h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><h3 id="创建与合并分支"><a href="#创建与合并分支" class="headerlink" title="创建与合并分支"></a>创建与合并分支</h3><p>在上文“版本回退”里，我们已经知道，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即<code>master</code>分支。<code>HEAD</code>严格来说不是指向提交，而是指向<code>master</code>，<code>master</code>才是指向提交的，所以，<code>HEAD</code>指向的就是当前分支。</p>
<p>一开始的时候，<code>master</code>分支是一条线，Git用<code>master</code>指向最新的提交，再用<code>HEAD</code>指向<code>master</code>，就能确定当前分支，以及当前分支的提交点：</p>
<p><img src="http://pic.guoyaohua.com/image/git/0.png" alt="img"></p>
<p>每次提交，<code>master</code>分支都会向前移动一步，这样，随着你不断提交，<code>master</code>分支的线也越来越长。</p>
<p>当我们创建新的分支，例如<code>dev</code>时，Git新建了一个指针叫<code>dev</code>，指向<code>master</code>相同的提交，再把<code>HEAD</code>指向<code>dev</code>，就表示当前分支在<code>dev</code>上：</p>
<p><img src="http://pic.guoyaohua.com/image/git/1.png" alt="img"></p>
<p>Git创建一个分支很快，因为除了增加一个<code>dev</code>指针，改改<code>HEAD</code>的指向，工作区的文件都没有任何变化。</p>
<p>不过，从现在开始，对工作区的修改和提交就是针对<code>dev</code>分支了，比如新提交一次后，<code>dev</code>指针往前移动一步，而<code>master</code>指针不变：</p>
<p><img src="http://pic.guoyaohua.com/image/git/2.png" alt="img"></p>
<p>假如我们在<code>dev</code>上的工作完成了，就可以把<code>dev</code>合并到<code>master</code>上。Git怎么合并呢？最简单的方法，就是直接把<code>master</code>指向<code>dev</code>的当前提交，就完成了合并：</p>
<p><img src="http://pic.guoyaohua.com/image/git/3.png" alt="img"></p>
<p>所以Git合并分支也很快！就改改指针，工作区内容也不变！</p>
<p>合并完分支后，甚至可以删除<code>dev</code>分支。删除<code>dev</code>分支就是把<code>dev</code>指针给删掉，删掉后，我们就剩下了一条<code>master</code>分支：</p>
<p><img src="http://pic.guoyaohua.com/image/git/4.png" alt="img"></p>
<p>下面开始实战。</p>
<p>首先，我们创建<code>dev</code>分支，然后切换到<code>dev</code>分支：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> git checkout <span class="literal">-b</span> dev</span><br><span class="line">Switched to a new branch <span class="string">&#x27;dev&#x27;</span></span><br></pre></td></tr></table></figure>

<p><code>git checkout</code>命令加上<code>-b</code>参数表示创建并切换，相当于以下两条命令：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> git branch dev <span class="comment"># 创建dev分支</span></span><br><span class="line"><span class="variable">$</span> git checkout dev <span class="comment"># 切换到dev分支</span></span><br><span class="line">Switched to branch <span class="string">&#x27;dev&#x27;</span></span><br></pre></td></tr></table></figure>

<p>然后，用<code>git branch</code>命令查看当前分支：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> git branch</span><br><span class="line">* dev</span><br><span class="line">  master</span><br></pre></td></tr></table></figure>

<p><code>git branch</code>命令会列出所有分支，当前分支前面会标一个<code>*</code>号。</p>
<p>然后，我们就可以在<code>dev</code>分支上正常提交，比如对<code>readme.txt</code>做个修改，加上一行：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">Creating a new branch is quick.</span><br></pre></td></tr></table></figure>

<p>然后提交：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> git add readme.txt </span><br><span class="line"><span class="variable">$</span> git commit <span class="literal">-m</span> <span class="string">&quot;branch test&quot;</span></span><br><span class="line">[<span class="type">dev</span> <span class="type">b17d20e</span>] branch test</span><br><span class="line"> <span class="number">1</span> file changed, <span class="number">1</span> insertion(+)</span><br></pre></td></tr></table></figure>

<p>现在，<code>dev</code>分支的工作完成，我们就可以切换回<code>master</code>分支：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> git checkout master</span><br><span class="line">Switched to branch <span class="string">&#x27;master&#x27;</span></span><br></pre></td></tr></table></figure>

<p>切换回<code>master</code>分支后，再查看一个<code>readme.txt</code>文件，刚才添加的内容不见了！因为那个提交是在<code>dev</code>分支上，而<code>master</code>分支此刻的提交点并没有变：</p>
<p><img src="http://pic.guoyaohua.com/image/git/5.png" alt="img"></p>
<p>现在，我们把<code>dev</code>分支的工作成果合并到<code>master</code>分支上：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> git merge dev</span><br><span class="line">Updating d46f35e..b17d20e</span><br><span class="line">Fast<span class="literal">-forward</span></span><br><span class="line"> readme.txt | <span class="number">1</span> +</span><br><span class="line"> <span class="number">1</span> file changed, <span class="number">1</span> insertion(+)</span><br></pre></td></tr></table></figure>

<p><code>git merge</code>命令用于合并指定分支到当前分支。合并后，再查看<code>readme.txt</code>的内容，就可以看到，和<code>dev</code>分支的最新提交是完全一样的。</p>
<p>注意到上面的<code>Fast-forward</code>信息，Git告诉我们，这次合并是“快进模式”，也就是直接把<code>master</code>指向<code>dev</code>的当前提交，所以合并速度非常快。</p>
<p>当然，也不是每次合并都能<code>Fast-forward</code>，我们后面会讲其他方式的合并。</p>
<p>合并完成后，就可以放心地删除<code>dev</code>分支了：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> git branch <span class="literal">-d</span> dev</span><br><span class="line">Deleted branch dev (was b17d20e).</span><br></pre></td></tr></table></figure>

<p>删除后，查看<code>branch</code>，就只剩下<code>master</code>分支了：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> git branch</span><br><span class="line">* master</span><br></pre></td></tr></table></figure>

<p>因为创建、合并和删除分支非常快，所以Git鼓励你使用分支完成某个任务，合并后再删掉分支，这和直接在<code>master</code>分支上工作效果是一样的，但过程更安全。</p>
<h3 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h3><p>在真正开发过程中，合并分支经常会遇到分支冲突的情况，无法直接合并，我们来模拟一下这个场景。</p>
<p>准备新的<code>feature1</code>分支，继续我们的新分支开发：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> git checkout <span class="literal">-b</span> feature1</span><br><span class="line">Switched to a new branch <span class="string">&#x27;feature1&#x27;</span></span><br></pre></td></tr></table></figure>

<p>修改<code>readme.txt</code>最后一行，改为：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">Creating a new branch is quick AND simple.</span><br></pre></td></tr></table></figure>

<p>在<code>feature1</code>分支上提交：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> git add readme.txt</span><br><span class="line"></span><br><span class="line"><span class="variable">$</span> git commit <span class="literal">-m</span> <span class="string">&quot;AND simple&quot;</span></span><br><span class="line">[<span class="type">feature1</span> <span class="number">14096</span><span class="type">d0</span>] AND simple</span><br><span class="line"> <span class="number">1</span> file changed, <span class="number">1</span> insertion(+), <span class="number">1</span> deletion(-)</span><br></pre></td></tr></table></figure>

<p>切换到<code>master</code>分支：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> git checkout master</span><br><span class="line">Switched to branch <span class="string">&#x27;master&#x27;</span></span><br><span class="line">Your branch is ahead of <span class="string">&#x27;origin/master&#x27;</span> by <span class="number">1</span> commit.</span><br><span class="line">  (use <span class="string">&quot;git push&quot;</span> to publish your local commits)</span><br></pre></td></tr></table></figure>

<p>Git还会自动提示我们当前<code>master</code>分支比远程的<code>master</code>分支要超前1个提交。</p>
<p>在<code>master</code>分支上把<code>readme.txt</code>文件的最后一行改为：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">Creating a new branch is quick &amp; simple.</span><br></pre></td></tr></table></figure>

<p>提交：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> git add readme.txt </span><br><span class="line"><span class="variable">$</span> git commit <span class="literal">-m</span> <span class="string">&quot;&amp; simple&quot;</span></span><br><span class="line">[<span class="type">master</span> <span class="number">5</span><span class="type">dc6824</span>] &amp; simple</span><br><span class="line"> <span class="number">1</span> file changed, <span class="number">1</span> insertion(+), <span class="number">1</span> deletion(-)</span><br></pre></td></tr></table></figure>

<p>现在，<code>master</code>分支和<code>feature1</code>分支各自都分别有新的提交，变成了这样：</p>
<p><img src="http://pic.guoyaohua.com/image/git/6.png" alt="img"></p>
<p>这种情况下，Git无法执行“快速合并(Fast-forward)”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突，我们试试看：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> git merge feature1</span><br><span class="line">Auto<span class="literal">-merging</span> readme.txt</span><br><span class="line">CONFLICT (content): Merge conflict <span class="keyword">in</span> readme.txt</span><br><span class="line">Automatic merge failed; fix conflicts and then commit the result.</span><br></pre></td></tr></table></figure>

<p>Git告诉我们，<code>readme.txt</code>文件存在冲突，必须手动解决冲突后再提交。<code>git status</code>也可以告诉我们冲突的文件：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is ahead of <span class="string">&#x27;origin/master&#x27;</span> by <span class="number">2</span> commits.</span><br><span class="line">  (use <span class="string">&quot;git push&quot;</span> to publish your local commits)</span><br><span class="line"></span><br><span class="line">You have unmerged paths.</span><br><span class="line">  (fix conflicts and run <span class="string">&quot;git commit&quot;</span>)</span><br><span class="line">  (use <span class="string">&quot;git merge --abort&quot;</span> to abort the merge)</span><br><span class="line"></span><br><span class="line">Unmerged paths:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to mark resolution)</span><br><span class="line"></span><br><span class="line">	both modified:   readme.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">&quot;git add&quot;</span> and/or <span class="string">&quot;git commit -a&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>我们可以直接查看readme.txt的内容：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br><span class="line">Git has a mutable index called stage.</span><br><span class="line">Git tracks changes of files.</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">Creating a new branch is quick &amp; simple.</span><br><span class="line">=======</span><br><span class="line">Creating a new branch is quick AND simple.</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1</span><br></pre></td></tr></table></figure>

<p>Git用<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，<code>=======</code>，<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>标记出不同分支的内容，我们修改如下后保存：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">Creating a new branch is quick and simple.</span><br></pre></td></tr></table></figure>

<p>再提交：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> git add readme.txt </span><br><span class="line"><span class="variable">$</span> git commit <span class="literal">-m</span> <span class="string">&quot;conflict fixed&quot;</span></span><br><span class="line">[<span class="type">master</span> <span class="type">cf810e4</span>] conflict fixed</span><br></pre></td></tr></table></figure>

<p>现在，<code>master</code>分支和<code>feature1</code>分支变成了下图所示：</p>
<p><img src="http://pic.guoyaohua.com/image/git/7.png" alt="img"></p>
<p>用带参数的<code>git log</code>也可以看到分支的合并情况：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> git log -<span class="literal">-graph</span> -<span class="literal">-pretty</span>=oneline -<span class="literal">-abbrev</span><span class="literal">-commit</span></span><br><span class="line">*   cf810e4 (HEAD -&gt; master) conflict fixed</span><br><span class="line">|\  </span><br><span class="line">| * <span class="number">14096</span>d0 (feature1) AND simple</span><br><span class="line">* | <span class="number">5</span>dc6824 &amp; simple</span><br><span class="line">|/  </span><br><span class="line">* b17d20e branch test</span><br><span class="line">* d46f35e (origin/master) remove test.txt</span><br><span class="line">* b84166e add test.txt</span><br><span class="line">* <span class="number">519219</span>b git tracks changes</span><br><span class="line">* e43a48b understand how stage works</span><br><span class="line">* <span class="number">1094</span>adb append GPL</span><br><span class="line">* e475afc add distributed</span><br><span class="line">* eaadf4e wrote a readme file</span><br></pre></td></tr></table></figure>

<p>最后，删除<code>feature1</code>分支：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> git branch <span class="literal">-d</span> feature1</span><br><span class="line">Deleted branch feature1 (was <span class="number">14096</span>d0).</span><br></pre></td></tr></table></figure>

<p>工作完成。</p>
<h3 id="分支管理策略"><a href="#分支管理策略" class="headerlink" title="分支管理策略"></a>分支管理策略</h3><p>通常，合并分支时，如果可能，Git会用<code>Fast forward</code>模式，但这种模式下，删除分支后，会丢掉分支信息。</p>
<p>如果要强制禁用<code>Fast forward</code>模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。</p>
<p>下面我们实战一下<code>--no-ff</code>方式的<code>git merge</code>：</p>
<p>首先，仍然创建并切换<code>dev</code>分支：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> git checkout <span class="literal">-b</span> dev</span><br><span class="line">Switched to a new branch <span class="string">&#x27;dev&#x27;</span></span><br></pre></td></tr></table></figure>

<p>修改readme.txt文件，并提交一个新的commit：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> git add readme.txt </span><br><span class="line"><span class="variable">$</span> git commit <span class="literal">-m</span> <span class="string">&quot;add merge&quot;</span></span><br><span class="line">[<span class="type">dev</span> <span class="type">f52c633</span>] add merge</span><br><span class="line"> <span class="number">1</span> file changed, <span class="number">1</span> insertion(+)</span><br></pre></td></tr></table></figure>

<p>现在，我们切换回<code>master</code>：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> git checkout master</span><br><span class="line">Switched to branch <span class="string">&#x27;master&#x27;</span></span><br></pre></td></tr></table></figure>

<p>准备合并<code>dev</code>分支，请注意<code>--no-ff</code>参数，表示禁用<code>Fast forward</code>：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> git merge -<span class="literal">-no</span><span class="literal">-ff</span> <span class="literal">-m</span> <span class="string">&quot;merge with no-ff&quot;</span> dev</span><br><span class="line">Merge made by the <span class="string">&#x27;recursive&#x27;</span> strategy.</span><br><span class="line"> readme.txt | <span class="number">1</span> +</span><br><span class="line"> <span class="number">1</span> file changed, <span class="number">1</span> insertion(+)</span><br></pre></td></tr></table></figure>

<p>因为本次合并要创建一个新的commit，所以加上<code>-m</code>参数，把commit描述写进去。</p>
<p>合并后，我们用<code>git log</code>看看分支历史：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> git log -<span class="literal">-graph</span> -<span class="literal">-pretty</span>=oneline -<span class="literal">-abbrev</span><span class="literal">-commit</span></span><br><span class="line">*   e1e9c68 (HEAD -&gt; master) merge with no<span class="literal">-ff</span></span><br><span class="line">|\  </span><br><span class="line">| * f52c633 (dev) add merge</span><br><span class="line">|/  </span><br><span class="line">*   cf810e4 conflict fixed</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>可以看到，不使用<code>Fast forward</code>模式，merge后就像这样：</p>
<p><img src="http://pic.guoyaohua.com/image/git/8.png" alt="img"></p>
<h4 id="分支策略"><a href="#分支策略" class="headerlink" title="分支策略"></a>分支策略</h4><p>在实际开发中，我们应该按照几个基本原则进行分支管理：</p>
<p>首先，<code>master</code>分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；</p>
<p>那在哪干活呢？干活都在<code>dev</code>分支上，也就是说，<code>dev</code>分支是不稳定的，到某个时候，比如1.0版本发布时，再把<code>dev</code>分支合并到<code>master</code>上，在<code>master</code>分支发布1.0版本；</p>
<p>你和团队同事每个人都在<code>dev</code>分支上干活，每个人都有自己的分支，时不时地往<code>dev</code>分支上合并就可以了。</p>
<p>所以，团队合作的分支看起来就像这样：</p>
<p><img src="http://pic.guoyaohua.com/image/git/9.png" alt="img"></p>
<h3 id="状态存储"><a href="#状态存储" class="headerlink" title="状态存储"></a>状态存储</h3><p>当我们在开发过程中，经常遇到这样的情况，我们需要暂时放下手中的工作，切换到其他分支进行开发，例如当我们在dev分支进行程序2.0版本开发时，发现1.0版本的程序出现了bug，必须立刻进行修复，但是在目前的dev分支我们可能已经做了很多修改，暂存区可能有了暂存状态，甚至可能在开发过程中在dev分支进行了多次commit，这时如果我们想切换回master分支，进行bug修复，这时就需要使用到<code>git stash</code>命令存储原分支当前的状态。</p>
<p>在讲解<code>git stash</code>之前，我们先考虑两种场景：</p>
<p>第一种就是我们未在dev分支进行任何提交，此时HEAD指针指向dev，dev和master指向同一次commit，如下图：</p>
<p><img src="http://pic.guoyaohua.com/image/git/1563631355797.png" alt="1563631355797"></p>
<p>我们可能在dev的工作区做了很多修改，也将部分修改状态加入了暂存区（即进行了<code>git add</code>操作），这时我们尝试一下直接使用<code>git checkout</code>命令切换分支。</p>
<p>此时，Git状态如下：</p>
<p><img src="http://pic.guoyaohua.com/image/git/1563631585919.png" alt="1563631585919"></p>
<p>我们修改“file1.txt”和“file2.txt”的内容，并将“file1.txt”的改动加入暂存区。</p>
<p><img src="http://pic.guoyaohua.com/image/git/1563631787056.png" alt="1563631787056"></p>
<p>此时可看出工作区和暂存区就都有改变，但HEAD指针指向的dev与master为同一个commit节点。</p>
<p>这时我们执行<code>git checkout master</code>命令尝试切换分支。</p>
<p><img src="http://pic.guoyaohua.com/image/git/1563631937563.png" alt="1563631937563"></p>
<p>可以看出，成功切换到了master分支上，而且工作区和暂存区的状态依旧保留。</p>
<p>我们再考虑一个场景，在dev分支开发时，进行了一次提交，此时HEAD指向dev分支，dev分支超前master分支一次commit，具体见下图：</p>
<p><img src="http://pic.guoyaohua.com/image/git/1563632158366.png" alt="1563632158366"></p>
<p>如果此时我们工作区或暂存区有未提交更改时，就无法进行分支切换操作（如果没有未提交修改的话当然可以进行分支切换操作）。</p>
<p><img src="http://pic.guoyaohua.com/image/git/1563632645976.png" alt="1563632645976"></p>
<p>我想这时大家就会有一个疑问，为什么两种状态下我们都修改了暂存区和工作区的状态，但是一个可以切换分支并且保留工作区、暂存区状态，而另一种状态就无法切换分支呢？</p>
<p>我起初在遇到这个问题的时候也是很诧异，在网上搜索了好多资料，依旧没有查到有价值的信息。</p>
<p>这时我们就应该从Git的原理来进行分析了，<strong>Git在进行版本控制时，记录的并不是文件本身的信息，而是文件的修改状态</strong>，例如我们再一个10000行代码的文件中，新加入了一行代码进行，Git并不是将最新的10001行代码作为备份，而是仅仅记录了新旧文件之间的差异，即在哪个位置修改了什么内容（修改包括：增加、删除、修改等）。</p>
<p>我们来分析一下上问题到的第一种场景：我们未在dev分支进行任何提交，此时HEAD指针指向dev，dev和master指向同一次commit。</p>
<p>虽然我们再dev分支的工作区和暂存区做了修改，这些修改都是基于dev指向的commit而言的，而且此时dev和master指向同一个commit，所以，该场景下，dev分支工作区和暂存区的修改依旧适用于master分支，所以可以成功切换分支。</p>
<p>而第二种场景：在dev分支开发时，进行了一次提交，此时HEAD指向dev分支，dev分支超前master分支一次commit。</p>
<p>这时，dev工作区和暂存区的状态是基于最新的dev指向的commit而言的，已经不能应用于master指向的commit了，所以在进行切换分支时，提示报错。</p>
<h4 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h4><p>软件开发中，bug就像家常便饭一样。有了bug就需要修复，在Git中，由于分支是如此的强大，所以，每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。</p>
<p>当你接到一个修复一个代号101的bug的任务时，很自然地，你想创建一个分支<code>issue-101</code>来修复它，但是，当前正在<code>dev</code>上进行的工作还没有提交：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> git status</span><br><span class="line">On branch dev</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">&quot;git reset HEAD &lt;file&gt;...&quot;</span> to unstage)</span><br><span class="line"></span><br><span class="line">	new file:   hello.py</span><br><span class="line"></span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">&quot;git checkout -- &lt;file&gt;...&quot;</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"></span><br><span class="line">	modified:   readme.txt</span><br></pre></td></tr></table></figure>

<p>并不是你不想提交，而是工作只进行到一半，还没法提交，预计完成还需1天时间。但是，必须在两个小时内修复该bug，怎么办？</p>
<p>幸好，Git还提供了一个<code>stash</code>功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> git stash</span><br><span class="line">Saved working directory and index state WIP on dev: f52c633 add merge</span><br></pre></td></tr></table></figure>

<p>现在，用<code>git status</code>查看工作区，就是干净的（除非有没有被Git管理的文件），因此可以放心地创建分支来修复bug。</p>
<p>首先确定要在哪个分支上修复bug，假定需要在<code>master</code>分支上修复，就从<code>master</code>创建临时分支：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> git checkout master</span><br><span class="line">Switched to branch <span class="string">&#x27;master&#x27;</span></span><br><span class="line">Your branch is ahead of <span class="string">&#x27;origin/master&#x27;</span> by <span class="number">6</span> commits.</span><br><span class="line">  (use <span class="string">&quot;git push&quot;</span> to publish your local commits)</span><br><span class="line"></span><br><span class="line"><span class="variable">$</span> git checkout <span class="literal">-b</span> issue<span class="literal">-101</span></span><br><span class="line">Switched to a new branch <span class="string">&#x27;issue-101&#x27;</span></span><br></pre></td></tr></table></figure>

<p>现在修复bug，需要把“Git is free software …”改为“Git is a free software …”，然后提交：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> git add readme.txt </span><br><span class="line"><span class="variable">$</span> git commit <span class="literal">-m</span> <span class="string">&quot;fix bug 101&quot;</span></span><br><span class="line">[<span class="type">issue</span>-<span class="number">101</span> <span class="number">4</span><span class="type">c805e2</span>] fix bug <span class="number">101</span></span><br><span class="line"> <span class="number">1</span> file changed, <span class="number">1</span> insertion(+), <span class="number">1</span> deletion(-)</span><br></pre></td></tr></table></figure>

<p>修复完成后，切换到<code>master</code>分支，并完成合并，最后删除<code>issue-101</code>分支：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> git checkout master</span><br><span class="line">Switched to branch <span class="string">&#x27;master&#x27;</span></span><br><span class="line">Your branch is ahead of <span class="string">&#x27;origin/master&#x27;</span> by <span class="number">6</span> commits.</span><br><span class="line">  (use <span class="string">&quot;git push&quot;</span> to publish your local commits)</span><br><span class="line"></span><br><span class="line"><span class="variable">$</span> git merge -<span class="literal">-no</span><span class="literal">-ff</span> <span class="literal">-m</span> <span class="string">&quot;merged bug fix 101&quot;</span> issue<span class="literal">-101</span></span><br><span class="line">Merge made by the <span class="string">&#x27;recursive&#x27;</span> strategy.</span><br><span class="line"> readme.txt | <span class="number">2</span> +-</span><br><span class="line"> <span class="number">1</span> file changed, <span class="number">1</span> insertion(+), <span class="number">1</span> deletion(-)</span><br></pre></td></tr></table></figure>

<p>修复好BUG之后，就可以返回原分支继续之前的工作了。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> git checkout dev</span><br><span class="line">Switched to branch <span class="string">&#x27;dev&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$</span> git status</span><br><span class="line">On branch dev</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure>

<p>工作区是干净的，刚才的工作现场存到哪去了？用<code>git stash list</code>命令看看：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> git stash list</span><br><span class="line">stash<span class="selector-tag">@</span>&#123;<span class="number">0</span>&#125;: WIP on dev: f52c633 add merge</span><br></pre></td></tr></table></figure>

<p>工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，有两个办法：</p>
<p>一是用<code>git stash apply</code>恢复，但是恢复后，stash内容并不删除，你需要用<code>git stash drop</code>来删除；</p>
<p>另一种方式是用<code>git stash pop</code>，恢复的同时把stash内容也删了：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> git stash pop</span><br><span class="line">On branch dev</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">&quot;git reset HEAD &lt;file&gt;...&quot;</span> to unstage)</span><br><span class="line"></span><br><span class="line">	new file:   hello.py</span><br><span class="line"></span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">&quot;git checkout -- &lt;file&gt;...&quot;</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"></span><br><span class="line">	modified:   readme.txt</span><br><span class="line"></span><br><span class="line">Dropped refs/stash<span class="selector-tag">@</span>&#123;<span class="number">0</span>&#125; (<span class="number">5</span>d677e2ee266f39ea296182fb2354265b91b3b2a)</span><br></pre></td></tr></table></figure>

<p>再用<code>git stash list</code>查看，就看不到任何stash内容了：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> git stash list</span><br></pre></td></tr></table></figure>

<p>你可以多次stash，恢复的时候，先用<code>git stash list</code>查看，然后恢复指定的stash，用命令：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> git stash apply stash<span class="selector-tag">@</span>&#123;<span class="number">0</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h3><p>当你从远程仓库克隆时，实际上Git自动把本地的<code>master</code>分支和远程的<code>master</code>分支对应起来了，并且，远程仓库的默认名称是<code>origin</code>。</p>
<p>用<code>git remote -v</code>查看远程库的详细信息：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> git remote <span class="literal">-v</span></span><br><span class="line">origin  git@github.com:guoyaohua/learngit.git (fetch)</span><br><span class="line">origin  git@github.com:guoyaohua/learngit.git (push)</span><br></pre></td></tr></table></figure>

<p>上面显示了可以抓取和推送的<code>origin</code>的地址。如果没有推送权限，就看不到push的地址。</p>
<h4 id="推送分支"><a href="#推送分支" class="headerlink" title="推送分支"></a>推送分支</h4><p>推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> git push origin master</span><br></pre></td></tr></table></figure>

<p>如果要推送其他分支，比如<code>dev</code>，就改成：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> git push origin dev</span><br></pre></td></tr></table></figure>

<p>但是，并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？</p>
<ul>
<li><code>master</code>分支是主分支，因此要时刻与远程同步；</li>
<li><code>dev</code>分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；</li>
<li>bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；</li>
<li>feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。</li>
</ul>
<p>总之，就是在Git中，分支完全可以在本地自己藏着玩，是否推送，视你的心情而定！</p>
<h4 id="抓取分支"><a href="#抓取分支" class="headerlink" title="抓取分支"></a>抓取分支</h4><p>多人协作时，大家都会往<code>master</code>和<code>dev</code>分支上推送各自的修改。</p>
<p>现在，模拟一个你的同事，可以在另一台电脑（注意要把SSH Key添加到GitHub）或者同一台电脑的另一个目录下克隆：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> git clone git@github.com:guoyaohua/learngit.git</span><br><span class="line">Cloning into <span class="string">&#x27;learngit&#x27;</span>...</span><br><span class="line">remote: Counting objects: <span class="number">40</span>, done.</span><br><span class="line">remote: Compressing objects: <span class="number">100</span>% (<span class="number">21</span>/<span class="number">21</span>), done.</span><br><span class="line">remote: Total <span class="number">40</span> (delta <span class="number">14</span>), reused <span class="number">40</span> (delta <span class="number">14</span>), pack<span class="literal">-reused</span> <span class="number">0</span></span><br><span class="line">Receiving objects: <span class="number">100</span>% (<span class="number">40</span>/<span class="number">40</span>), done.</span><br><span class="line">Resolving deltas: <span class="number">100</span>% (<span class="number">14</span>/<span class="number">14</span>), done.</span><br></pre></td></tr></table></figure>

<p>当你的同事从远程库clone时，默认情况下，你的同事只能看到本地的<code>master</code>分支。不信可以用<code>git branch</code>命令看看：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> git branch</span><br><span class="line">* master</span><br></pre></td></tr></table></figure>

<p>现在，你的同事要在<code>dev</code>分支上开发，就必须创建远程<code>origin</code>的<code>dev</code>分支到本地，于是他用这个命令创建本地<code>dev</code>分支：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> git checkout <span class="literal">-b</span> dev origin/dev</span><br></pre></td></tr></table></figure>

<p>现在，他就可以在<code>dev</code>上继续修改，然后，时不时地把<code>dev</code>分支<code>push</code>到远程：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> git add env.txt</span><br><span class="line"></span><br><span class="line"><span class="variable">$</span> git commit <span class="literal">-m</span> <span class="string">&quot;add env&quot;</span></span><br><span class="line">[<span class="type">dev</span> <span class="number">7</span><span class="type">a5e5dd</span>] add env</span><br><span class="line"> <span class="number">1</span> file changed, <span class="number">1</span> insertion(+)</span><br><span class="line"> create mode <span class="number">100644</span> env.txt</span><br><span class="line"></span><br><span class="line"><span class="variable">$</span> git push origin dev</span><br><span class="line">Counting objects: <span class="number">3</span>, done.</span><br><span class="line">Delta compression <span class="keyword">using</span> up to 4 threads.</span><br><span class="line">Compressing objects: <span class="number">100</span>% (<span class="number">2</span>/<span class="number">2</span>), done.</span><br><span class="line">Writing objects: <span class="number">100</span>% (<span class="number">3</span>/<span class="number">3</span>), <span class="number">308</span> bytes | <span class="number">308.00</span> KiB/s, done.</span><br><span class="line">Total <span class="number">3</span> (delta <span class="number">0</span>), reused <span class="number">0</span> (delta <span class="number">0</span>)</span><br><span class="line">To github.com:michaelliao/learngit.git</span><br><span class="line">   f52c633..<span class="number">7</span>a5e5dd  dev -&gt; dev</span><br></pre></td></tr></table></figure>

<p>你的同事已经向<code>origin/dev</code>分支推送了他的提交，而碰巧你也对同样的文件作了修改，并试图推送：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> <span class="built_in">type</span> env.txt</span><br><span class="line">env</span><br><span class="line"></span><br><span class="line"><span class="variable">$</span> git add env.txt</span><br><span class="line"></span><br><span class="line"><span class="variable">$</span> git commit <span class="literal">-m</span> <span class="string">&quot;add new env&quot;</span></span><br><span class="line">[<span class="type">dev</span> <span class="number">7</span><span class="type">bd91f1</span>] add new env</span><br><span class="line"> <span class="number">1</span> file changed, <span class="number">1</span> insertion(+)</span><br><span class="line"> create mode <span class="number">100644</span> env.txt</span><br><span class="line"></span><br><span class="line"><span class="variable">$</span> git push origin dev</span><br><span class="line">To github.com:michaelliao/learngit.git</span><br><span class="line"> ! [<span class="type">rejected</span>]        dev -&gt; dev (non<span class="literal">-fast</span><span class="literal">-forward</span>)</span><br><span class="line">error: failed to push some refs to <span class="string">&#x27;git@github.com:guoyaohua/learngit.git&#x27;</span></span><br><span class="line">hint: Updates were rejected because the tip of your current branch is behind</span><br><span class="line">hint: its remote counterpart. Integrate the remote changes (e.g.</span><br><span class="line">hint: <span class="string">&#x27;git pull ...&#x27;</span>) before pushing again.</span><br><span class="line">hint: See the <span class="string">&#x27;Note about fast-forwards&#x27;</span> <span class="keyword">in</span> <span class="string">&#x27;git push --help&#x27;</span> <span class="keyword">for</span> details.</span><br></pre></td></tr></table></figure>

<p>推送失败，因为你的同事的最新提交和你试图推送的提交有冲突，解决办法也很简单，Git已经提示我们，先用<code>git pull</code>把最新的提交从<code>origin/dev</code>抓下来，然后，在本地合并，解决冲突，再推送：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> git pull</span><br><span class="line">There is no tracking information <span class="keyword">for</span> the current branch.</span><br><span class="line">Please specify which branch you want to merge with.</span><br><span class="line">See git<span class="literal">-pull</span>(<span class="number">1</span>) <span class="keyword">for</span> details.</span><br><span class="line"></span><br><span class="line">    git pull &lt;remote&gt; &lt;branch&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">If</span> you wish to <span class="built_in">set</span> tracking information <span class="keyword">for</span> this branch you can <span class="keyword">do</span> so with:</span><br><span class="line"></span><br><span class="line">    git branch -<span class="literal">-set</span><span class="literal">-upstream</span><span class="literal">-to</span>=origin/&lt;branch&gt; dev</span><br></pre></td></tr></table></figure>

<p><code>git pull</code>也失败了，原因是没有指定本地<code>dev</code>分支与远程<code>origin/dev</code>分支的链接，根据提示，设置<code>dev</code>和<code>origin/dev</code>的链接：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> git branch -<span class="literal">-set</span><span class="literal">-upstream</span><span class="literal">-to</span>=origin/dev dev</span><br><span class="line">Branch <span class="string">&#x27;dev&#x27;</span> <span class="built_in">set</span> up to track remote branch <span class="string">&#x27;dev&#x27;</span> from <span class="string">&#x27;origin&#x27;</span>.</span><br></pre></td></tr></table></figure>

<p>再pull：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> git pull</span><br><span class="line">Auto<span class="literal">-merging</span> env.txt</span><br><span class="line">CONFLICT (add/add): Merge conflict <span class="keyword">in</span> env.txt</span><br><span class="line">Automatic merge failed; fix conflicts and then commit the result.</span><br></pre></td></tr></table></figure>

<p>这回<code>git pull</code>成功，但是合并有冲突，需要手动解决，解决的方法和分支管理中的解决冲突完全一样。解决后，提交，再push：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> git commit <span class="literal">-m</span> <span class="string">&quot;fix env conflict&quot;</span></span><br><span class="line">[<span class="type">dev</span> <span class="number">57</span><span class="type">c53ab</span>] fix env conflict</span><br><span class="line"></span><br><span class="line"><span class="variable">$</span> git push origin dev</span><br><span class="line">Counting objects: <span class="number">6</span>, done.</span><br><span class="line">Delta compression <span class="keyword">using</span> up to 4 threads.</span><br><span class="line">Compressing objects: <span class="number">100</span>% (<span class="number">4</span>/<span class="number">4</span>), done.</span><br><span class="line">Writing objects: <span class="number">100</span>% (<span class="number">6</span>/<span class="number">6</span>), <span class="number">621</span> bytes | <span class="number">621.00</span> KiB/s, done.</span><br><span class="line">Total <span class="number">6</span> (delta <span class="number">0</span>), reused <span class="number">0</span> (delta <span class="number">0</span>)</span><br><span class="line">To git@github.com:guoyaohua/learngit.git</span><br><span class="line">   <span class="number">7</span>a5e5dd..<span class="number">57</span>c53ab  dev -&gt; dev</span><br></pre></td></tr></table></figure>

<p>因此，多人协作的工作模式通常是这样：</p>
<ol>
<li>首先，可以试图用<code>git push origin &lt;branch-name&gt;</code>推送自己的修改；</li>
<li>如果推送失败，则因为远程分支比你的本地更新，需要先用<code>git pull</code>试图合并；</li>
<li>如果合并有冲突，则解决冲突，并在本地提交；</li>
<li>没有冲突或者解决掉冲突后，再用<code>git push origin &lt;branch-name&gt;</code>推送就能成功！</li>
</ol>
<p>如果<code>git pull</code>提示<code>no tracking information</code>，则说明本地分支和远程分支的链接关系没有创建，用命令<code>git branch --set-upstream-to &lt;branch-name&gt; origin/&lt;branch-name&gt;</code>。</p>
<p>这就是多人协作的工作模式，一旦熟悉了，就非常简单。</p>
<h3 id="Rebase"><a href="#Rebase" class="headerlink" title="Rebase"></a>Rebase</h3><p><code>git rebase</code>和<code>git merge</code>做的事其实是一样的。它们都被设计来将一个分支的更改并入另一个分支，只不过方式有些不同。</p>
<p><code>git rebase</code>用于把一个分支的修改合并到当前分支。</p>
<p>假设你现在基于远程分支”origin”，创建一个叫”mywork”的分支。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> git checkout <span class="literal">-b</span> mywork origin</span><br></pre></td></tr></table></figure>

<p>假设远程分支”origin”已经有了2个提交，如图：</p>
<p><img src="http://pic.guoyaohua.com/image/git/rebase0.png" alt="img"></p>
<p>现在我们在这个分支做一些修改，然后生成两个提交(commit)。</p>
<p>但是与此同时，有些人也在”origin”分支上做了一些修改并且做了提交了. 这就意味着”origin”和”mywork”这两个分支各自”前进”了，它们之间”分叉”了。</p>
<p><img src="http://pic.guoyaohua.com/image/git/rebase1.png" alt="img"></p>
<p>在这里，你可以用“pull”命令把“origin”分支上的修改拉下来并且和你的修改合并； 结果看起来就像一个新的”合并的提交”(merge commit):</p>
<p><img src="http://pic.guoyaohua.com/image/git/rebase2.png" alt="img"></p>
<p>但是，如果你想让“mywork”分支历史看起来像没有经过任何合并一样，你也许可以用 <code>git rebase</code>：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> git checkout mywork</span><br><span class="line"><span class="variable">$</span> git rebase origin</span><br></pre></td></tr></table></figure>

<p>这些命令会把你的”mywork”分支里的每个提交(commit)取消掉，并且把它们临时保存为补丁(patch)(这些补丁放到”.git/rebase”目录中)，然后把”mywork”分支更新为最新的”origin”分支，最后把保存的这些补丁应用到”mywork”分支上。</p>
<p><img src="http://pic.guoyaohua.com/image/git/rebase3.png" alt="img"></p>
<p>当”mywork”分支更新之后，它会指向这些新创建的提交(commit)，而那些老的提交会被丢弃。 如果运行垃圾收集命令(pruning garbage collection)，这些被丢弃的提交就会删除。</p>
<p><img src="http://pic.guoyaohua.com/image/git/rebase4.png" alt="img"></p>
<p>现在我们可以看一下用merge和用rebase所产生的历史的区别：</p>
<p><img src="http://pic.guoyaohua.com/image/git/1563677573806.png" alt="1563677573806"></p>
<p><img src="http://pic.guoyaohua.com/image/git/rebase2.png" alt="img"></p>
<p>当我们使用<code>git log</code>来参看commit时，其commit的顺序也有所不同。</p>
<p>假设C3提交于<code>9:00AM</code>，C5提交于<code>10:00AM</code>，C4提交于<code>11:00AM</code>，C6提交于<code>12:00AM</code>，</p>
<p>对于使用<code>git merge</code>来合并所看到的commit的顺序（从新到旧）是：</p>
<p>C7，C6，C4，C5，C3，C2，C1</p>
<p>对于使用git rebase来合并所看到的commit的顺序（从新到旧）是：</p>
<p>C7，C6’，C5’，C4，C3，C2，C1</p>
<p>因为C6’提交只是C6提交的克隆，C5’提交只是C5提交的克隆，</p>
<p>从用户的角度看使用<code>git rebase</code>来合并后所看到的commit的顺序（从新到旧）是：</p>
<p>C7，C6，C5，C4，C3，C2，C1</p>
<p>另外，我们在使用<code>git pull</code>命令的时候，可以使用<code>--rebase</code>参数，即<code>git pull --rebase</code>，这里Git会把你的本地当前分支里的每个提交(commit)取消掉，并且把它们临时保存为补丁(patch)(这些补丁放到”.git/rebase”目录中),然后把分支更新 为最新的”origin”分支，最后把保存的这些补丁应用到分支上。</p>
<h4 id="解决冲突-1"><a href="#解决冲突-1" class="headerlink" title="解决冲突"></a>解决冲突</h4><p>在rebase的过程中，也许会出现冲突(conflict)。在这种情况，Git会停止rebase并会让你去解决冲突。rebase和merge的另一个区别是rebase的冲突是一个一个解决，如果有十个冲突，在解决完第一个冲突后，用”<code>git add</code>“命令去更新这些内容的索引(index)，然后，你无需执行 git-commit，只要执行：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> git add <span class="literal">-u</span> </span><br><span class="line"><span class="variable">$</span> git rebase -<span class="literal">-continue</span></span><br></pre></td></tr></table></figure>

<p>继续后才会出现第二个冲突，直到所有冲突解决完，而merge是所有的冲突都会显示出来。</p>
<p>在任何时候，你可以用<code>--abort</code>参数来终止rebase的行动，并且”mywork” 分支会回到rebase开始前的状态。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> git rebase -<span class="literal">-abort</span></span><br></pre></td></tr></table></figure>

<p>所以rebase的工作流就是</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">git rebase </span><br><span class="line"><span class="keyword">while</span>(存在冲突) &#123;</span><br><span class="line">    git status</span><br><span class="line">    <span class="comment"># 找到当前冲突文件，编辑解决冲突</span></span><br><span class="line">    git add <span class="literal">-u</span></span><br><span class="line">    git rebase -<span class="literal">-continue</span></span><br><span class="line">    <span class="keyword">if</span>( git rebase -<span class="literal">-abort</span> )</span><br><span class="line">        <span class="keyword">break</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后冲突全部解决，rebase成功。</p>
<h2 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h2><p>发布一个版本时，我们通常先在版本库中打一个标签（tag），这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。</p>
<p>Git的标签虽然是版本库的快照，但其实它就是指向某个commit的指针（跟分支很像，但是分支可以移动，标签不能移动），所以，创建和删除标签都是瞬间完成的。</p>
<p>Git有commit，为什么还要引入tag？</p>
<p>“请把上周一的那个版本打包发布，commit号是6a5819e…”</p>
<p>“一串乱七八糟的数字不好找！”</p>
<p>如果换一个办法：</p>
<p>“请把上周一的那个版本打包发布，版本号是v1.2”</p>
<p>“好的，按照tag v1.2查找commit就行！”</p>
<p>所以，tag就是一个让人容易记住的有意义的名字，它跟某个commit绑在一起。</p>
<h3 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h3><p>在Git中打标签非常简单，首先，切换到需要打标签的分支上：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> git branch</span><br><span class="line">* dev</span><br><span class="line">  master</span><br><span class="line"><span class="variable">$</span> git checkout master</span><br><span class="line">Switched to branch <span class="string">&#x27;master&#x27;</span></span><br></pre></td></tr></table></figure>

<p>然后，敲命令<code>git tag &lt;name&gt;</code>就可以打一个新标签：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> git tag v1.<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>可以用命令<code>git tag</code>查看所有标签：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> git tag</span><br><span class="line">v1.<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>默认标签是打在最新提交的commit上的。有时候，如果忘了打标签，比如，现在已经是周五了，但应该在周一打的标签没有打，怎么办？</p>
<p>方法是找到历史提交的commit id，然后打上就可以了：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> git log -<span class="literal">-pretty</span>=oneline -<span class="literal">-abbrev</span><span class="literal">-commit</span></span><br><span class="line"><span class="number">12</span>a631b (HEAD -&gt; master, tag: v1.<span class="number">0</span>, origin/master) merged bug fix <span class="number">101</span></span><br><span class="line"><span class="number">4</span>c805e2 fix bug <span class="number">101</span></span><br><span class="line">e1e9c68 merge with no<span class="literal">-ff</span></span><br><span class="line">f52c633 add merge</span><br><span class="line">cf810e4 conflict fixed</span><br><span class="line"><span class="number">5</span>dc6824 &amp; simple</span><br><span class="line"><span class="number">14096</span>d0 AND simple</span><br><span class="line">b17d20e branch test</span><br><span class="line">d46f35e remove test.txt</span><br><span class="line">b84166e add test.txt</span><br><span class="line"><span class="number">519219</span>b git tracks changes</span><br><span class="line">e43a48b understand how stage works</span><br><span class="line"><span class="number">1094</span>adb append GPL</span><br><span class="line">e475afc add distributed</span><br><span class="line">eaadf4e wrote a readme file</span><br></pre></td></tr></table></figure>

<p>比方说要对<code>add merge</code>这次提交打标签，它对应的commit id是<code>f52c633</code>，敲入命令：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> git tag v0.<span class="number">9</span> f52c633</span><br></pre></td></tr></table></figure>

<p>再用命令<code>git tag</code>查看标签：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> git tag</span><br><span class="line">v0.<span class="number">9</span></span><br><span class="line">v1.<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>注意，标签不是按时间顺序列出，而是按字母排序的。可以用<code>git show &lt;tagname&gt;</code>查看标签信息：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> git show v0.<span class="number">9</span></span><br><span class="line">commit f52c63349bc3c1593499807e5c8e972b82c8f286 (tag: v0.<span class="number">9</span>)</span><br><span class="line">Author: Yaohua Guo &lt;guo.yaohua@foxmail.com&gt;</span><br><span class="line">Date:   Fri May <span class="number">18</span> <span class="number">21</span>:<span class="number">56</span>:<span class="number">54</span> <span class="number">2018</span> +<span class="number">0800</span></span><br><span class="line"></span><br><span class="line">    add merge</span><br><span class="line"></span><br><span class="line"><span class="built_in">diff</span> -<span class="literal">-git</span> a/readme.txt b/readme.txt</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>可以看到，<code>v0.9</code>确实打在<code>add merge</code>这次提交上。</p>
<p>还可以创建带有说明的标签，用<code>-a</code>指定标签名，<code>-m</code>指定说明文字：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> git tag <span class="literal">-a</span> v0.<span class="number">1</span> <span class="literal">-m</span> <span class="string">&quot;version 0.1 released&quot;</span> <span class="number">1094</span>adb</span><br></pre></td></tr></table></figure>

<p>用命令<code>git show &lt;tagname&gt;</code>可以看到说明文字：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> git show v0.<span class="number">1</span></span><br><span class="line">tag v0.<span class="number">1</span></span><br><span class="line">Tagger: Yaohua Guo &lt;guo.yaohua@foxmail.com&gt;</span><br><span class="line">Date:   Fri May <span class="number">18</span> <span class="number">22</span>:<span class="number">48</span>:<span class="number">43</span> <span class="number">2018</span> +<span class="number">0800</span></span><br><span class="line"></span><br><span class="line">version <span class="number">0.1</span> released</span><br><span class="line"></span><br><span class="line">commit <span class="number">1094</span>adb7b9b3807259d8cb349e7df1d4d6477073 (tag: v0.<span class="number">1</span>)</span><br><span class="line">Author: Yaohua Guo &lt;guo.yaohua@foxmail.com&gt;</span><br><span class="line">Date:   Fri May <span class="number">18</span> <span class="number">21</span>:<span class="number">06</span>:<span class="number">15</span> <span class="number">2018</span> +<span class="number">0800</span></span><br><span class="line"></span><br><span class="line">    append GPL</span><br><span class="line"></span><br><span class="line"><span class="built_in">diff</span> -<span class="literal">-git</span> a/readme.txt b/readme.txt</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="操作标签"><a href="#操作标签" class="headerlink" title="操作标签"></a>操作标签</h3><p>如果标签打错了，也可以删除：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> git tag <span class="literal">-d</span> v0.<span class="number">1</span></span><br><span class="line">Deleted tag <span class="string">&#x27;v0.1&#x27;</span> (was f15b0dd)</span><br></pre></td></tr></table></figure>

<p>因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。</p>
<p>如果要推送某个标签到远程，使用命令<code>git push origin &lt;tagname&gt;</code>：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> git push origin v1.<span class="number">0</span></span><br><span class="line">Total <span class="number">0</span> (delta <span class="number">0</span>), reused <span class="number">0</span> (delta <span class="number">0</span>)</span><br><span class="line">To git@github.com:guoyaohua/learngit.git</span><br><span class="line"> * [<span class="type">new</span> <span class="type">tag</span>]         v1.<span class="number">0</span> -&gt; v1.<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>或者，一次性推送全部尚未推送到远程的本地标签：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> git push origin -<span class="literal">-tags</span></span><br><span class="line">Total <span class="number">0</span> (delta <span class="number">0</span>), reused <span class="number">0</span> (delta <span class="number">0</span>)</span><br><span class="line">To git@github.com:guoyaohua/learngit.git</span><br><span class="line"> * [<span class="type">new</span> <span class="type">tag</span>]         v0.<span class="number">9</span> -&gt; v0.<span class="number">9</span></span><br></pre></td></tr></table></figure>

<p>如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> git tag <span class="literal">-d</span> v0.<span class="number">9</span></span><br><span class="line">Deleted tag <span class="string">&#x27;v0.9&#x27;</span> (was f52c633)</span><br></pre></td></tr></table></figure>

<p>然后，从远程删除。删除命令也是push，但是格式如下：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> git push origin :refs/tags/v0.<span class="number">9</span></span><br><span class="line">To git@github.com:guoyaohua/learngit.git</span><br><span class="line"> - [<span class="type">deleted</span>]         v0.<span class="number">9</span></span><br></pre></td></tr></table></figure>

<p>要看看是否真的从远程库删除了标签，可以登陆GitHub查看。</p>
<h2 id="自定义Git"><a href="#自定义Git" class="headerlink" title="自定义Git"></a>自定义Git</h2><h3 id="忽略特殊文件"><a href="#忽略特殊文件" class="headerlink" title="忽略特殊文件"></a>忽略特殊文件</h3><p>有些时候，你必须把某些文件放到Git工作目录中，但又不能提交它们，比如保存了数据库密码的配置文件啦，等等，每次<code>git status</code>都会显示<code>Untracked files ...</code>，有强迫症的朋友心里肯定不爽。</p>
<p>好在Git考虑到了大家的感受，这个问题解决起来也很简单，在Git工作区的根目录下创建一个特殊的<code>.gitignore</code>文件，然后把要忽略的文件名填进去，Git就会自动忽略这些文件。</p>
<p>不需要从头写<code>.gitignore</code>文件，GitHub已经为我们准备了各种配置文件，只需要组合一下就可以使用了。所有配置文件可以直接在线浏览：<a href="https://github.com/github/gitignore">https://github.com/github/gitignore</a></p>
<p>忽略文件的原则是：</p>
<ol>
<li>忽略操作系统自动生成的文件，比如缩略图等；</li>
<li>忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的<code>.class</code>文件；</li>
<li>忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。</li>
</ol>
<p>举个例子：</p>
<p>假设你在Windows下进行Python开发，Windows会自动在有图片的目录下生成隐藏的缩略图文件，如果有自定义目录，目录下就会有<code>Desktop.ini</code>文件，因此你需要忽略Windows自动生成的垃圾文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Windows:</span><br><span class="line">Thumbs.db</span><br><span class="line">ehthumbs.db</span><br><span class="line">Desktop.ini</span><br></pre></td></tr></table></figure>

<p>然后，继续忽略Python编译产生的<code>.pyc</code>、<code>.pyo</code>、<code>dist</code>等文件或目录：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Python:</span><br><span class="line">*.py[cod]</span><br><span class="line">*.so</span><br><span class="line">*.egg</span><br><span class="line">*.egg-info</span><br><span class="line">dist</span><br><span class="line">build</span><br></pre></td></tr></table></figure>

<p>加上你自己定义的文件，最终得到一个完整的<code>.gitignore</code>文件，内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Windows:</span><br><span class="line">Thumbs.db</span><br><span class="line">ehthumbs.db</span><br><span class="line">Desktop.ini</span><br><span class="line"></span><br><span class="line"># Python:</span><br><span class="line">*.py[cod]</span><br><span class="line">*.so</span><br><span class="line">*.egg</span><br><span class="line">*.egg-info</span><br><span class="line">dist</span><br><span class="line">build</span><br><span class="line"></span><br><span class="line"># My configurations:</span><br><span class="line">db.ini</span><br><span class="line">deploy_key_rsa</span><br></pre></td></tr></table></figure>

<p>最后一步就是把<code>.gitignore</code>也提交到Git，就完成了！当然检验<code>.gitignore</code>的标准是<code>git status</code>命令是不是说<code>working directory clean</code>。</p>
<p>使用Windows的朋友注意了，如果你在资源管理器里新建一个<code>.gitignore</code>文件，它会非常弱智地提示你必须输入文件名，但是在文本编辑器里“保存”或者“另存为”就可以把文件保存为<code>.gitignore</code>了。</p>
<p>有些时候，你想添加一个文件到Git，但发现添加不了，原因是这个文件被<code>.gitignore</code>忽略了：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> git add App.class</span><br><span class="line">The following paths are ignored by one of your .gitignore files:</span><br><span class="line">App.class</span><br><span class="line">Use <span class="operator">-f</span> <span class="keyword">if</span> you really want to add them.</span><br></pre></td></tr></table></figure>

<p>如果你确实想添加该文件，可以用<code>-f</code>强制添加到Git：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> git add <span class="operator">-f</span> App.class</span><br></pre></td></tr></table></figure>

<p>或者你发现，可能是<code>.gitignore</code>写得有问题，需要找出来到底哪个规则写错了，可以用<code>git check-ignore</code>命令检查：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> git check<span class="literal">-ignore</span> <span class="literal">-v</span> App.class</span><br><span class="line">.gitignore:<span class="number">3</span>:*.class	App.class</span><br></pre></td></tr></table></figure>

<p>Git会告诉我们，<code>.gitignore</code>的第3行规则忽略了该文件，于是我们就可以知道应该修订哪个规则。</p>
<h3 id="配置别名"><a href="#配置别名" class="headerlink" title="配置别名"></a>配置别名</h3><p>有没有经常敲错命令？比如<code>git status</code>？<code>status</code>这个单词真心不好记。</p>
<p>如果敲<code>git st</code>就表示<code>git status</code>那就简单多了，当然这种偷懒的办法我们是极力赞成的。</p>
<p>我们只需要敲一行命令，告诉Git，以后<code>st</code>就表示<code>status</code>：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> git config -<span class="literal">-global</span> alias.st status</span><br></pre></td></tr></table></figure>

<p>好了，现在敲<code>git st</code>看看效果。</p>
<p>当然还有别的命令可以简写，很多人都用<code>co</code>表示<code>checkout</code>，<code>ci</code>表示<code>commit</code>，<code>br</code>表示<code>branch</code>：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> git config -<span class="literal">-global</span> alias.co checkout</span><br><span class="line"><span class="variable">$</span> git config -<span class="literal">-global</span> alias.ci commit</span><br><span class="line"><span class="variable">$</span> git config -<span class="literal">-global</span> alias.br branch</span><br></pre></td></tr></table></figure>

<p>以后提交就可以简写成：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> git ci <span class="literal">-m</span> <span class="string">&quot;bala bala bala...&quot;</span></span><br></pre></td></tr></table></figure>

<p><code>--global</code>参数是全局参数，也就是这些命令在这台电脑的所有Git仓库下都有用。</p>
<p>在撤销修改一节中，我们知道，命令<code>git reset HEAD file</code>可以把暂存区的修改撤销掉（unstage），重新放回工作区。既然是一个unstage操作，就可以配置一个<code>unstage</code>别名：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> git config -<span class="literal">-global</span> alias.unstage <span class="string">&#x27;reset HEAD&#x27;</span></span><br></pre></td></tr></table></figure>

<p>当你敲入命令：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> git unstage test.py</span><br></pre></td></tr></table></figure>

<p>实际上Git执行的是：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> git reset HEAD test.py</span><br></pre></td></tr></table></figure>

<p>配置一个<code>git last</code>，让其显示最后一次提交信息：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> git config -<span class="literal">-global</span> alias.last <span class="string">&#x27;log -1&#x27;</span></span><br></pre></td></tr></table></figure>

<p>这样，用<code>git last</code>就能显示最近一次的提交：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> git last</span><br><span class="line">commit adca45d317e6d8a4b23f9811c3d7b7f0f180bfe2</span><br><span class="line">Merge: bd6ae48 <span class="number">291</span>bea8</span><br><span class="line">Author: Yaohua Guo &lt;Guo.Yaohua@foxmail.com&gt;</span><br><span class="line">Date:   Thu Aug <span class="number">22</span> <span class="number">22</span>:<span class="number">49</span>:<span class="number">22</span> <span class="number">2013</span> +<span class="number">0800</span></span><br><span class="line"></span><br><span class="line">    merge &amp; fix hello.py</span><br></pre></td></tr></table></figure>

<p>甚至可以进一步美化把<code>lg</code>配置成：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> git config -<span class="literal">-global</span> alias.lg <span class="string">&quot;log --color --graph --pretty=format:&#x27;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#x27; --abbrev-commit&quot;</span></span><br></pre></td></tr></table></figure>

<p>来看看<code>git lg</code>的效果：</p>
<p><img src="http://pic.guoyaohua.com/image/git/10.png" alt="img"></p>
<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>配置Git的时候，加上<code>--global</code>是针对当前用户起作用的，如果不加，那只针对当前的仓库起作用。</p>
<p>配置文件放哪了？每个仓库的Git配置文件都放在<code>.git/config</code>文件中：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> <span class="built_in">type</span> .git/config </span><br><span class="line">[<span class="type">core</span>]</span><br><span class="line">    repositoryformatversion = <span class="number">0</span></span><br><span class="line">    filemode = true</span><br><span class="line">    bare = false</span><br><span class="line">    logallrefupdates = true</span><br><span class="line">    ignorecase = true</span><br><span class="line">    precomposeunicode = true</span><br><span class="line">[<span class="type">remote</span> <span class="string">&quot;origin&quot;</span>]</span><br><span class="line">    url = git@github.com:michaelliao/learngit.git</span><br><span class="line">    fetch = +refs/heads/*:refs/remotes/origin/*</span><br><span class="line">[<span class="type">branch</span> <span class="string">&quot;master&quot;</span>]</span><br><span class="line">    remote = origin</span><br><span class="line">    merge = refs/heads/master</span><br><span class="line">[<span class="type">alias</span>]</span><br><span class="line">    last = log <span class="literal">-1</span></span><br></pre></td></tr></table></figure>

<p>别名就在<code>[alias]</code>后面，要删除别名，直接把对应的行删掉即可。</p>
<p>而当前用户的Git配置文件放在用户主目录下的一个隐藏文件<code>.gitconfig</code>中：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> <span class="built_in">type</span> .gitconfig</span><br><span class="line">[<span class="type">alias</span>]</span><br><span class="line">    co = checkout</span><br><span class="line">    ci = commit</span><br><span class="line">    br = branch</span><br><span class="line">    st = status</span><br><span class="line">[<span class="type">user</span>]</span><br><span class="line">    name = Your Name</span><br><span class="line">    email = your@email.com</span><br></pre></td></tr></table></figure>

<p>配置别名也可以直接修改这个文件，如果改错了，可以删掉文件重新通过命令配置。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>Git记录的是文件的修改状态，而不是文件本身。</li>
<li>初始化一个Git仓库，使用<code>git init</code>命令。</li>
<li>添加文件到Git仓库，分两步：<ul>
<li>使用命令<code>git add &lt;file&gt;</code>，注意，可反复多次使用，添加多个文件；</li>
<li>使用命令<code>git commit -m &lt;message&gt;</code>，完成。</li>
</ul>
</li>
<li>每次修改，如果不用<code>git add</code>到暂存区，那就不会加入到<code>commit</code>中。</li>
<li>提交后，可用<code>git diff HEAD -- &lt;file_name&gt;</code>命令可以查看工作区和版本库里面最新版本的区别。</li>
<li>要关联一个远程库，使用命令<code>git remote add origin git@server-name:path/repo-name.git</code>，使用命令<code>git push -u origin master</code>第一次推送master分支的所有内容，此后，每次本地提交后，只要有必要，就可以使用命令<code>git push origin master</code>推送最新修改。</li>
<li>要克隆一个仓库，首先必须知道仓库的地址，然后使用<code>git clone</code>命令克隆。Git支持多种协议，包括<code>https</code>，但通过<code>ssh</code>支持的原生<code>git</code>协议速度最快。</li>
<li>HEAD<code>指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令</code>git reset –hard commit_id`。</li>
<li>穿梭前，用<code>git log</code>可以查看提交历史，以便确定要回退到哪个版本。</li>
<li>要重返未来，用<code>git reflog</code>查看命令历史，以便确定要回到未来的哪个版本。</li>
<li>当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令<code>git checkout -- file</code>。</li>
<li>当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令<code>git reset HEAD &lt;file&gt;</code>，第二步按上一条操作。</li>
<li>已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退，不过前提是没有推送到远程库。</li>
<li>命令<code>git rm</code>用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失<strong>最近一次提交后你修改的内容</strong>。</li>
<li>Git鼓励大量使用分支：<ul>
<li>查看分支：<code>git branch</code></li>
<li>创建分支：<code>git branch &lt;name&gt;</code></li>
<li>切换分支：<code>git checkout &lt;name&gt;</code></li>
<li>创建+切换分支：<code>git checkout -b &lt;name&gt;</code></li>
<li>合并某分支到当前分支：<code>git merge &lt;name&gt;</code></li>
<li>删除分支：<code>git branch -d &lt;name&gt;</code></li>
</ul>
</li>
<li>当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。</li>
<li>用<code>git log --graph</code>命令可以看到分支合并图。</li>
<li>合并分支时，加上<code>--no-ff</code>参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而<code>fast forward</code>合并就看不出来曾经做过合并。</li>
<li>切换分支使用<code>git checkout &lt;master&gt;</code> ，HEAD指向master，工作区也恢复到master的状态。</li>
<li>开发一个新feature，最好新建一个分支。</li>
<li>如果要丢弃一个没有被合并过的分支，可以通过<code>git branch -D &lt;name&gt;</code>强行删除。</li>
<li>查看远程库信息，使用<code>git remote -v</code>。</li>
<li>本地新建的分支如果不推送到远程，对其他人就是不可见的。</li>
<li>从本地推送分支，使用<code>git push origin branch-name</code>，如果推送失败，先用<code>git pull</code>抓取远程的新提交。</li>
<li>在本地创建和远程分支对应的分支，使用<code>git checkout -b branch-name origin/branch-name</code>，本地和远程分支的名称最好一致。</li>
<li>建立本地分支和远程分支的关联，使用<code>git branch --set-upstream branch-name origin/branch-name</code>。</li>
<li>从远程抓取分支，使用<code>git pull</code>，如果有冲突，要先处理冲突。</li>
<li>命令<code>git tag &lt;tagname&gt;</code>用于新建一个标签，默认为<code>HEAD</code>，也可以指定一个commit id。</li>
<li>命令<code>git tag -a &lt;tagname&gt; -m &quot;blablabla...&quot;</code>可以指定标签信息。</li>
<li>命令<code>git tag</code>可以查看所有标签。</li>
<li>忽略某些文件时，需要编写<code>.gitignore</code>。</li>
<li><code>.gitignore</code>文件本身要放到版本库里，并且可以对<code>.gitignore</code>做版本管理。</li>
</ol>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git 学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Sqlite3 C/C++</title>
    <url>/2021/08/11/Sqlite3-C-C/</url>
    <content><![CDATA[<h1 id="SQLite-C-C"><a href="#SQLite-C-C" class="headerlink" title="SQLite - C/C++"></a>SQLite - C/C++</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文是简单的sqlite3 c++ 接口应用，源自[菜鸟教程](<a href="https://www.runoob.com/sqlite/sqlite-c-cpp.html">SQLite – C/C++ | 菜鸟教程 (runoob.com)</a>)，以便查询</p>
<span id="more"></span>

<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>在 C/C++ 程序中使用 SQLite 之前，我们需要确保机器上已经有 SQLite 库。可以查看 SQLite 安装章节了解安装过程。</p>
<h2 id="C-C-接口-API"><a href="#C-C-接口-API" class="headerlink" title="C/C++ 接口 API"></a>C/C++ 接口 API</h2><p>以下是重要的 C&amp;C++ / SQLite 接口程序，可以满足您在 C/C++ 程序中使用 SQLite 数据库的需求。如果您需要了解更多细节，请查看 SQLite 官方文档。</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">API &amp; 描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">*<em>sqlite3_open(const char *filename, sqlite3 *<em>ppDb)</em></em> 该例程打开一个指向 SQLite 数据库文件的连接，返回一个用于其他 SQLite 程序的数据库连接对象。如果 <em>filename</em> 参数是 NULL 或 ‘:memory:’，那么 sqlite3_open() 将会在 RAM 中创建一个内存数据库，这只会在 session 的有效时间内持续。如果文件名 filename 不为 NULL，那么 sqlite3_open() 将使用这个参数值尝试打开数据库文件。如果该名称的文件不存在，sqlite3_open() 将创建一个新的命名为该名称的数据库文件并打开。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>sqlite3_exec(sqlite3*, const char *sql, sqlite_callback, void *data, char * errmsg)</strong> 该例程提供了一个执行 SQL 命令的快捷方式，SQL 命令由 sql 参数提供，可以由多个 SQL 命令组成。在这里，第一个参数 <em>sqlite3</em> 是打开的数据库对象，<em>sqlite_callback</em> 是一个回调，<em>data</em> 作为其第一个参数，errmsg 将被返回用来获取程序生成的任何错误。sqlite3_exec() 程序解析并执行由 <strong>sql</strong> 参数所给的每个命令，直到字符串结束或者遇到错误为止。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>sqlite3_close(sqlite3*)</strong> 该例程关闭之前调用 sqlite3_open() 打开的数据库连接。所有与连接相关的语句都应在连接关闭之前完成。如果还有查询没有完成，sqlite3_close() 将返回 SQLITE_BUSY 禁止关闭的错误消息。</td>
</tr>
</tbody></table>
<h2 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h2><p>下面的 C 代码段显示了如何连接到一个现有的数据库。如果数据库不存在，那么它就会被创建，最后将返回一个数据库对象。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sqlite3.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   sqlite3 *db;</span><br><span class="line">   <span class="keyword">char</span> *zErrMsg = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">int</span> rc;</span><br><span class="line"></span><br><span class="line">   rc = <span class="built_in">sqlite3_open</span>(<span class="string">&quot;test.db&quot;</span>, &amp;db);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span>( rc )&#123;</span><br><span class="line">      <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Can&#x27;t open database: %s\n&quot;</span>, <span class="built_in">sqlite3_errmsg</span>(db));</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Opened database successfully\n&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">sqlite3_close</span>(db);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，让我们来编译和运行上面的程序，在当前目录中创建我们的数据库 <strong>test.db</strong>。您可以根据需要改变路径。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="variable">$gcc</span> test.c -l sqlite3</span><br><span class="line">$./a.out</span><br><span class="line">Opened database successfully</span><br></pre></td></tr></table></figure>

<p>如果要使用 C++ 源代码，可以按照下列所示编译代码：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="variable">$g</span>++ test.c -l sqlite3</span><br></pre></td></tr></table></figure>

<p>在这里，把我们的程序链接上 sqlite3 库，以便向 C 程序提供必要的函数。这将在您的目录下创建一个数据库文件 test.db，您将得到如下结果：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">-rwxr-xr-x. 1 root root 7383 May  8 02:06 a.out</span><br><span class="line">-rw-r--r--. 1 root root  323 May  8 02:05 test.c</span><br><span class="line">-rw-r--r--. 1 root root    0 May  8 02:06 test.db</span><br></pre></td></tr></table></figure>

<h2 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h2><p>下面的 C 代码段将用于在先前创建的数据库中创建一个表：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sqlite3.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">callback</span><span class="params">(<span class="keyword">void</span> *NotUsed, <span class="keyword">int</span> argc, <span class="keyword">char</span> **argv, <span class="keyword">char</span> **azColName)</span></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> i;</span><br><span class="line">   <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;argc; i++)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%s = %s\n&quot;</span>, azColName[i], argv[i] ? argv[i] : <span class="string">&quot;NULL&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   sqlite3 *db;</span><br><span class="line">   <span class="keyword">char</span> *zErrMsg = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">int</span>  rc;</span><br><span class="line">   <span class="keyword">char</span> *sql;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* Open database */</span></span><br><span class="line">   rc = <span class="built_in">sqlite3_open</span>(<span class="string">&quot;test.db&quot;</span>, &amp;db);</span><br><span class="line">   <span class="keyword">if</span>( rc )&#123;</span><br><span class="line">      <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Can&#x27;t open database: %s\n&quot;</span>, <span class="built_in">sqlite3_errmsg</span>(db));</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="built_in">fprintf</span>(stdout, <span class="string">&quot;Opened database successfully\n&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* Create SQL statement */</span></span><br><span class="line">   sql = <span class="string">&quot;CREATE TABLE COMPANY(&quot;</span>  \</span><br><span class="line">         <span class="string">&quot;ID INT PRIMARY KEY     NOT NULL,&quot;</span> \</span><br><span class="line">         <span class="string">&quot;NAME           TEXT    NOT NULL,&quot;</span> \</span><br><span class="line">         <span class="string">&quot;AGE            INT     NOT NULL,&quot;</span> \</span><br><span class="line">         <span class="string">&quot;ADDRESS        CHAR(50),&quot;</span> \</span><br><span class="line">         <span class="string">&quot;SALARY         REAL );&quot;</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* Execute SQL statement */</span></span><br><span class="line">   rc = <span class="built_in">sqlite3_exec</span>(db, sql, callback, <span class="number">0</span>, &amp;zErrMsg);</span><br><span class="line">   <span class="keyword">if</span>( rc != SQLITE_OK )&#123;</span><br><span class="line">   <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;SQL error: %s\n&quot;</span>, zErrMsg);</span><br><span class="line">      <span class="built_in">sqlite3_free</span>(zErrMsg);</span><br><span class="line">   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="built_in">fprintf</span>(stdout, <span class="string">&quot;Table created successfully\n&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">sqlite3_close</span>(db);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序编译和执行时，它会在 test.db 文件中创建 COMPANY 表，最终文件列表如下所示：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">-rwxr-xr-x. 1 root root 9567 May  8 02:31 a.out</span><br><span class="line">-rw-r--r--. 1 root root 1207 May  8 02:31 test.c</span><br><span class="line">-rw-r--r--. 1 root root 3072 May  8 02:31 test.db</span><br></pre></td></tr></table></figure>

<h2 id="INSERT-操作"><a href="#INSERT-操作" class="headerlink" title="INSERT 操作"></a>INSERT 操作</h2><p>下面的 C 代码段显示了如何在上面创建的 COMPANY 表中创建记录：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sqlite3.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">callback</span><span class="params">(<span class="keyword">void</span> *NotUsed, <span class="keyword">int</span> argc, <span class="keyword">char</span> **argv, <span class="keyword">char</span> **azColName)</span></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> i;</span><br><span class="line">   <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;argc; i++)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%s = %s\n&quot;</span>, azColName[i], argv[i] ? argv[i] : <span class="string">&quot;NULL&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   sqlite3 *db;</span><br><span class="line">   <span class="keyword">char</span> *zErrMsg = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">int</span> rc;</span><br><span class="line">   <span class="keyword">char</span> *sql;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* Open database */</span></span><br><span class="line">   rc = <span class="built_in">sqlite3_open</span>(<span class="string">&quot;test.db&quot;</span>, &amp;db);</span><br><span class="line">   <span class="keyword">if</span>( rc )&#123;</span><br><span class="line">      <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Can&#x27;t open database: %s\n&quot;</span>, <span class="built_in">sqlite3_errmsg</span>(db));</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Opened database successfully\n&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* Create SQL statement */</span></span><br><span class="line">   sql = <span class="string">&quot;INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY) &quot;</span>  \</span><br><span class="line">         <span class="string">&quot;VALUES (1, &#x27;Paul&#x27;, 32, &#x27;California&#x27;, 20000.00 ); &quot;</span> \</span><br><span class="line">         <span class="string">&quot;INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY) &quot;</span>  \</span><br><span class="line">         <span class="string">&quot;VALUES (2, &#x27;Allen&#x27;, 25, &#x27;Texas&#x27;, 15000.00 ); &quot;</span>     \</span><br><span class="line">         <span class="string">&quot;INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY)&quot;</span> \</span><br><span class="line">         <span class="string">&quot;VALUES (3, &#x27;Teddy&#x27;, 23, &#x27;Norway&#x27;, 20000.00 );&quot;</span> \</span><br><span class="line">         <span class="string">&quot;INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY)&quot;</span> \</span><br><span class="line">         <span class="string">&quot;VALUES (4, &#x27;Mark&#x27;, 25, &#x27;Rich-Mond &#x27;, 65000.00 );&quot;</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* Execute SQL statement */</span></span><br><span class="line">   rc = <span class="built_in">sqlite3_exec</span>(db, sql, callback, <span class="number">0</span>, &amp;zErrMsg);</span><br><span class="line">   <span class="keyword">if</span>( rc != SQLITE_OK )&#123;</span><br><span class="line">      <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;SQL error: %s\n&quot;</span>, zErrMsg);</span><br><span class="line">      <span class="built_in">sqlite3_free</span>(zErrMsg);</span><br><span class="line">   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="built_in">fprintf</span>(stdout, <span class="string">&quot;Records created successfully\n&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">sqlite3_close</span>(db);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序编译和执行时，它会在 COMPANY 表中创建给定记录，并会显示以下两行：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Opened database successfully</span><br><span class="line">Records created successfully</span><br></pre></td></tr></table></figure>

<h2 id="SELECT-操作"><a href="#SELECT-操作" class="headerlink" title="SELECT 操作"></a>SELECT 操作</h2><p>在我们开始讲解获取记录的实例之前，让我们先了解下回调函数的一些细节，这将在我们的实例使用到。这个回调提供了一个从 SELECT 语句获得结果的方式。它声明如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*sqlite3_callback)</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">void</span>*,    <span class="comment">/* Data provided in the 4th argument of sqlite3_exec() */</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">int</span>,      <span class="comment">/* The number of columns in row */</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">char</span>**,   <span class="comment">/* An array of strings representing fields in the row */</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">char</span>**    <span class="comment">/* An array of strings representing column names */</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>如果上面的回调在 sqlite_exec() 程序中作为第三个参数，那么 SQLite 将为 SQL 参数内执行的每个 SELECT 语句中处理的每个记录调用这个回调函数。</p>
<p>下面的 C 代码段显示了如何从前面创建的 COMPANY 表中获取并显示记录：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sqlite3.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">callback</span><span class="params">(<span class="keyword">void</span> *data, <span class="keyword">int</span> argc, <span class="keyword">char</span> **argv, <span class="keyword">char</span> **azColName)</span></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> i;</span><br><span class="line">   <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;%s: &quot;</span>, (<span class="keyword">const</span> <span class="keyword">char</span>*)data);</span><br><span class="line">   <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;argc; i++)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%s = %s\n&quot;</span>, azColName[i], argv[i] ? argv[i] : <span class="string">&quot;NULL&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   sqlite3 *db;</span><br><span class="line">   <span class="keyword">char</span> *zErrMsg = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">int</span> rc;</span><br><span class="line">   <span class="keyword">char</span> *sql;</span><br><span class="line">   <span class="keyword">const</span> <span class="keyword">char</span>* data = <span class="string">&quot;Callback function called&quot;</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* Open database */</span></span><br><span class="line">   rc = <span class="built_in">sqlite3_open</span>(<span class="string">&quot;test.db&quot;</span>, &amp;db);</span><br><span class="line">   <span class="keyword">if</span>( rc )&#123;</span><br><span class="line">      <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Can&#x27;t open database: %s\n&quot;</span>, <span class="built_in">sqlite3_errmsg</span>(db));</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Opened database successfully\n&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* Create SQL statement */</span></span><br><span class="line">   sql = <span class="string">&quot;SELECT * from COMPANY&quot;</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* Execute SQL statement */</span></span><br><span class="line">   rc = <span class="built_in">sqlite3_exec</span>(db, sql, callback, (<span class="keyword">void</span>*)data, &amp;zErrMsg);</span><br><span class="line">   <span class="keyword">if</span>( rc != SQLITE_OK )&#123;</span><br><span class="line">      <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;SQL error: %s\n&quot;</span>, zErrMsg);</span><br><span class="line">      <span class="built_in">sqlite3_free</span>(zErrMsg);</span><br><span class="line">   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="built_in">fprintf</span>(stdout, <span class="string">&quot;Operation done successfully\n&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">sqlite3_close</span>(db);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序编译和执行时，它会产生以下结果：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">Opened database successfully</span><br><span class="line">Callback <span class="keyword">function</span> <span class="keyword">called</span>: ID <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">NAME <span class="operator">=</span> Paul</span><br><span class="line">AGE <span class="operator">=</span> <span class="number">32</span></span><br><span class="line">ADDRESS <span class="operator">=</span> California</span><br><span class="line">SALARY <span class="operator">=</span> <span class="number">20000.0</span></span><br><span class="line"></span><br><span class="line">Callback <span class="keyword">function</span> <span class="keyword">called</span>: ID <span class="operator">=</span> <span class="number">2</span></span><br><span class="line">NAME <span class="operator">=</span> Allen</span><br><span class="line">AGE <span class="operator">=</span> <span class="number">25</span></span><br><span class="line">ADDRESS <span class="operator">=</span> Texas</span><br><span class="line">SALARY <span class="operator">=</span> <span class="number">15000.0</span></span><br><span class="line"></span><br><span class="line">Callback <span class="keyword">function</span> <span class="keyword">called</span>: ID <span class="operator">=</span> <span class="number">3</span></span><br><span class="line">NAME <span class="operator">=</span> Teddy</span><br><span class="line">AGE <span class="operator">=</span> <span class="number">23</span></span><br><span class="line">ADDRESS <span class="operator">=</span> Norway</span><br><span class="line">SALARY <span class="operator">=</span> <span class="number">20000.0</span></span><br><span class="line"></span><br><span class="line">Callback <span class="keyword">function</span> <span class="keyword">called</span>: ID <span class="operator">=</span> <span class="number">4</span></span><br><span class="line">NAME <span class="operator">=</span> Mark</span><br><span class="line">AGE <span class="operator">=</span> <span class="number">25</span></span><br><span class="line">ADDRESS <span class="operator">=</span> Rich<span class="operator">-</span>Mond</span><br><span class="line">SALARY <span class="operator">=</span> <span class="number">65000.0</span></span><br><span class="line"></span><br><span class="line">Operation done successfully</span><br></pre></td></tr></table></figure>

<h2 id="UPDATE-操作"><a href="#UPDATE-操作" class="headerlink" title="UPDATE 操作"></a>UPDATE 操作</h2><p>下面的 C 代码段显示了如何使用 UPDATE 语句来更新任何记录，然后从 COMPANY 表中获取并显示更新的记录：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sqlite3.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">callback</span><span class="params">(<span class="keyword">void</span> *data, <span class="keyword">int</span> argc, <span class="keyword">char</span> **argv, <span class="keyword">char</span> **azColName)</span></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> i;</span><br><span class="line">   <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;%s: &quot;</span>, (<span class="keyword">const</span> <span class="keyword">char</span>*)data);</span><br><span class="line">   <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;argc; i++)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%s = %s\n&quot;</span>, azColName[i], argv[i] ? argv[i] : <span class="string">&quot;NULL&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   sqlite3 *db;</span><br><span class="line">   <span class="keyword">char</span> *zErrMsg = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">int</span> rc;</span><br><span class="line">   <span class="keyword">char</span> *sql;</span><br><span class="line">   <span class="keyword">const</span> <span class="keyword">char</span>* data = <span class="string">&quot;Callback function called&quot;</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* Open database */</span></span><br><span class="line">   rc = <span class="built_in">sqlite3_open</span>(<span class="string">&quot;test.db&quot;</span>, &amp;db);</span><br><span class="line">   <span class="keyword">if</span>( rc )&#123;</span><br><span class="line">      <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Can&#x27;t open database: %s\n&quot;</span>, <span class="built_in">sqlite3_errmsg</span>(db));</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Opened database successfully\n&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* Create merged SQL statement */</span></span><br><span class="line">   sql = <span class="string">&quot;UPDATE COMPANY set SALARY = 25000.00 where ID=1; &quot;</span> \</span><br><span class="line">         <span class="string">&quot;SELECT * from COMPANY&quot;</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* Execute SQL statement */</span></span><br><span class="line">   rc = <span class="built_in">sqlite3_exec</span>(db, sql, callback, (<span class="keyword">void</span>*)data, &amp;zErrMsg);</span><br><span class="line">   <span class="keyword">if</span>( rc != SQLITE_OK )&#123;</span><br><span class="line">      <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;SQL error: %s\n&quot;</span>, zErrMsg);</span><br><span class="line">      <span class="built_in">sqlite3_free</span>(zErrMsg);</span><br><span class="line">   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="built_in">fprintf</span>(stdout, <span class="string">&quot;Operation done successfully\n&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">sqlite3_close</span>(db);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序编译和执行时，它会产生以下结果：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Opened database successfully</span><br><span class="line">Callback function called: ID = <span class="number">1</span></span><br><span class="line">NAME = Paul</span><br><span class="line">AGE = <span class="number">32</span></span><br><span class="line">ADDRESS = California</span><br><span class="line">SALARY = <span class="number">25000.0</span></span><br><span class="line"></span><br><span class="line">Callback function called: ID = <span class="number">2</span></span><br><span class="line">NAME = Allen</span><br><span class="line">AGE = <span class="number">25</span></span><br><span class="line">ADDRESS = Texas</span><br><span class="line">SALARY = <span class="number">15000.0</span></span><br><span class="line"></span><br><span class="line">Callback function called: ID = <span class="number">3</span></span><br><span class="line">NAME = Teddy</span><br><span class="line">AGE = <span class="number">23</span></span><br><span class="line">ADDRESS = Norway</span><br><span class="line">SALARY = <span class="number">20000.0</span></span><br><span class="line"></span><br><span class="line">Callback function called: ID = <span class="number">4</span></span><br><span class="line">NAME = Mark</span><br><span class="line">AGE = <span class="number">25</span></span><br><span class="line">ADDRESS = Rich-Mond</span><br><span class="line">SALARY = <span class="number">65000.0</span></span><br><span class="line"></span><br><span class="line">Operation done successfully</span><br></pre></td></tr></table></figure>

<h2 id="DELETE-操作"><a href="#DELETE-操作" class="headerlink" title="DELETE 操作"></a>DELETE 操作</h2><p>下面的 C 代码段显示了如何使用 DELETE 语句删除任何记录，然后从 COMPANY 表中获取并显示剩余的记录：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sqlite3.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">callback</span><span class="params">(<span class="keyword">void</span> *data, <span class="keyword">int</span> argc, <span class="keyword">char</span> **argv, <span class="keyword">char</span> **azColName)</span></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> i;</span><br><span class="line">   <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;%s: &quot;</span>, (<span class="keyword">const</span> <span class="keyword">char</span>*)data);</span><br><span class="line">   <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;argc; i++)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%s = %s\n&quot;</span>, azColName[i], argv[i] ? argv[i] : <span class="string">&quot;NULL&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   sqlite3 *db;</span><br><span class="line">   <span class="keyword">char</span> *zErrMsg = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">int</span> rc;</span><br><span class="line">   <span class="keyword">char</span> *sql;</span><br><span class="line">   <span class="keyword">const</span> <span class="keyword">char</span>* data = <span class="string">&quot;Callback function called&quot;</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* Open database */</span></span><br><span class="line">   rc = <span class="built_in">sqlite3_open</span>(<span class="string">&quot;test.db&quot;</span>, &amp;db);</span><br><span class="line">   <span class="keyword">if</span>( rc )&#123;</span><br><span class="line">      <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Can&#x27;t open database: %s\n&quot;</span>, <span class="built_in">sqlite3_errmsg</span>(db));</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Opened database successfully\n&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* Create merged SQL statement */</span></span><br><span class="line">   sql = <span class="string">&quot;DELETE from COMPANY where ID=2; &quot;</span> \</span><br><span class="line">         <span class="string">&quot;SELECT * from COMPANY&quot;</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* Execute SQL statement */</span></span><br><span class="line">   rc = <span class="built_in">sqlite3_exec</span>(db, sql, callback, (<span class="keyword">void</span>*)data, &amp;zErrMsg);</span><br><span class="line">   <span class="keyword">if</span>( rc != SQLITE_OK )&#123;</span><br><span class="line">      <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;SQL error: %s\n&quot;</span>, zErrMsg);</span><br><span class="line">      <span class="built_in">sqlite3_free</span>(zErrMsg);</span><br><span class="line">   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="built_in">fprintf</span>(stdout, <span class="string">&quot;Operation done successfully\n&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">sqlite3_close</span>(db);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序编译和执行时，它会产生以下结果：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">Opened database successfully</span><br><span class="line">Callback <span class="keyword">function</span> <span class="keyword">called</span>: ID <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">NAME <span class="operator">=</span> Paul</span><br><span class="line">AGE <span class="operator">=</span> <span class="number">32</span></span><br><span class="line">ADDRESS <span class="operator">=</span> California</span><br><span class="line">SALARY <span class="operator">=</span> <span class="number">20000.0</span></span><br><span class="line"></span><br><span class="line">Callback <span class="keyword">function</span> <span class="keyword">called</span>: ID <span class="operator">=</span> <span class="number">3</span></span><br><span class="line">NAME <span class="operator">=</span> Teddy</span><br><span class="line">AGE <span class="operator">=</span> <span class="number">23</span></span><br><span class="line">ADDRESS <span class="operator">=</span> Norway</span><br><span class="line">SALARY <span class="operator">=</span> <span class="number">20000.0</span></span><br><span class="line"></span><br><span class="line">Callback <span class="keyword">function</span> <span class="keyword">called</span>: ID <span class="operator">=</span> <span class="number">4</span></span><br><span class="line">NAME <span class="operator">=</span> Mark</span><br><span class="line">AGE <span class="operator">=</span> <span class="number">25</span></span><br><span class="line">ADDRESS <span class="operator">=</span> Rich<span class="operator">-</span>Mond</span><br><span class="line">SALARY <span class="operator">=</span> <span class="number">65000.0</span></span><br><span class="line"></span><br><span class="line">Operation done successfully</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Sqlite3</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>sqlite3</tag>
      </tags>
  </entry>
  <entry>
    <title>Sqlite3 简单使用</title>
    <url>/2021/08/11/Sqlite3-%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本文介绍一些常用Sqlite3 命令行。</p>
<span id="more"></span>

<h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$ sqlite3 database_name.db</span><br><span class="line">或者</span><br><span class="line">sqlite<span class="operator">&gt;</span> .<span class="keyword">open</span> database_name.db</span><br></pre></td></tr></table></figure>

<h3 id="附加数据库"><a href="#附加数据库" class="headerlink" title="附加数据库"></a>附加数据库</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">ATTACH DATABASE <span class="string">&#x27;file_name&#x27;</span> <span class="keyword">AS</span> <span class="string">&#x27;alias_name&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="分离数据库"><a href="#分离数据库" class="headerlink" title="分离数据库"></a>分离数据库</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DETACH DATABASE <span class="string">&#x27;alias_name&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>如果是临时数据库或直接销毁。</p>
<h3 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name(</span><br><span class="line">    xx		<span class="type">INT</span>		(<span class="keyword">NOT</span> <span class="keyword">NULL</span>),</span><br><span class="line">    xx		TEXT	(<span class="keyword">NOT</span> <span class="keyword">NULL</span>),</span><br><span class="line">    xx		<span class="type">CHAR</span>(<span class="number">5</span>)	(<span class="keyword">NOT</span> <span class="keyword">NULL</span>),</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY(xx, xx, ...)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h3 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> table_name;</span><br></pre></td></tr></table></figure>

<h3 id="INSERT"><a href="#INSERT" class="headerlink" title="INSERT"></a>INSERT</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name [(col1, col2, col3, ..., coln)]</span><br><span class="line"><span class="keyword">VALUES</span> (val1, val2, val3, ..., valn);</span><br></pre></td></tr></table></figure>

<h3 id="SELECT"><a href="#SELECT" class="headerlink" title="SELECT"></a>SELECT</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> col1, col2, col3</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> [<span class="keyword">CONDITION</span>]</span><br></pre></td></tr></table></figure>

<h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">描述</th>
<th align="left">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">==</td>
<td align="left">检查两个操作数的值是否相等，如果相等则条件为真。</td>
<td align="left">(a == b) 不为真。</td>
</tr>
<tr>
<td align="left">=</td>
<td align="left">检查两个操作数的值是否相等，如果相等则条件为真。</td>
<td align="left">(a = b) 不为真。</td>
</tr>
<tr>
<td align="left">!=</td>
<td align="left">检查两个操作数的值是否相等，如果不相等则条件为真。</td>
<td align="left">(a != b) 为真。</td>
</tr>
<tr>
<td align="left">&lt;&gt;</td>
<td align="left">检查两个操作数的值是否相等，如果不相等则条件为真。</td>
<td align="left">(a &lt;&gt; b) 为真。</td>
</tr>
<tr>
<td align="left">&gt;</td>
<td align="left">检查左操作数的值是否大于右操作数的值，如果是则条件为真。</td>
<td align="left">(a &gt; b) 不为真。</td>
</tr>
<tr>
<td align="left">&lt;</td>
<td align="left">检查左操作数的值是否小于右操作数的值，如果是则条件为真。</td>
<td align="left">(a &lt; b) 为真。</td>
</tr>
<tr>
<td align="left">&gt;=</td>
<td align="left">检查左操作数的值是否大于等于右操作数的值，如果是则条件为真。</td>
<td align="left">(a &gt;= b) 不为真。</td>
</tr>
<tr>
<td align="left">&lt;=</td>
<td align="left">检查左操作数的值是否小于等于右操作数的值，如果是则条件为真。</td>
<td align="left">(a &lt;= b) 为真。</td>
</tr>
<tr>
<td align="left">!&lt;</td>
<td align="left">检查左操作数的值是否不小于右操作数的值，如果是则条件为真。</td>
<td align="left">(a !&lt; b) 为假。</td>
</tr>
<tr>
<td align="left">!&gt;</td>
<td align="left">检查左操作数的值是否不大于右操作数的值，如果是则条件为真。</td>
<td align="left">(a !&gt; b) 为真。</td>
</tr>
</tbody></table>
<h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>AND</td>
<td>AND运算符允许在一个SQL语句中的WHERE子句中的多个条件的存在</td>
</tr>
<tr>
<td>BETWEEN</td>
<td>BETWEEN 运算符用于在给定最小值和最大值范围内的一系列值中搜索值。</td>
</tr>
<tr>
<td>EXISTS</td>
<td>EXISTS 运算符用于在满足一定条件的指定表中搜索行的存在。</td>
</tr>
<tr>
<td>IN</td>
<td>IN 运算符用于把某个值与一系列指定列表的值进行比较。</td>
</tr>
<tr>
<td>NOT IN</td>
<td>IN 运算符的对立面，用于把某个值与不在一系列指定列表的值进行比较。</td>
</tr>
<tr>
<td>LIKE</td>
<td>LIKE 运算符用于把某个值与使用通配符运算符的相似值进行比较。</td>
</tr>
<tr>
<td>GLOB</td>
<td>GLOB 运算符用于把某个值与使用通配符运算符的相似值进行比较。GLOB 与 LIKE 不同之处在于，它是<strong>大小写敏感</strong>的。</td>
</tr>
<tr>
<td>NOT</td>
<td>NOT 运算符是所用的逻辑运算符的对立面。比如 NOT EXISTS、NOT BETWEEN、NOT IN，等等。<strong>它是否定运算符。</strong></td>
</tr>
<tr>
<td>OR</td>
<td>OR 运算符用于结合一个 SQL 语句的 WHERE 子句中的多个条件。</td>
</tr>
<tr>
<td>IS NULL</td>
<td>NULL 运算符用于把某个值与 NULL 值进行比较。</td>
</tr>
<tr>
<td>IS</td>
<td>IS 运算符与 = 相似。</td>
</tr>
<tr>
<td>IS NOT</td>
<td>IS NOT 运算符与 != 相似。</td>
</tr>
<tr>
<td>||</td>
<td>连接两个不同的字符串，得到一个新的字符串。</td>
</tr>
<tr>
<td>UNIQUE</td>
<td>UNIQUE 运算符搜索指定表中的每一行，确保唯一性（无重复）。</td>
</tr>
</tbody></table>
<h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">描述</th>
<th align="left">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">&amp;</td>
<td align="left">如果同时存在于两个操作数中，二进制 AND 运算符复制一位到结果中。</td>
<td align="left">(A &amp; B) 将得到 12，即为 0000 1100</td>
</tr>
<tr>
<td align="left">|</td>
<td align="left">如果存在于任一操作数中，二进制 OR 运算符复制一位到结果中。</td>
<td align="left">(A | B) 将得到 61，即为 0011 1101</td>
</tr>
<tr>
<td align="left">~</td>
<td align="left">二进制补码运算符是一元运算符，具有”翻转”位效应，即0变成1，1变成0。</td>
<td align="left">(~A ) 将得到 -61，即为 1100 0011，一个有符号二进制数的补码形式。</td>
</tr>
<tr>
<td align="left">&lt;&lt;</td>
<td align="left">二进制左移运算符。左操作数的值向左移动右操作数指定的位数。</td>
<td align="left">A &lt;&lt; 2 将得到 240，即为 1111 0000</td>
</tr>
</tbody></table>
<h3 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h3><p>是一个或多个值、运算符和计算值的SQL函数的组合。与公式类似，都写在查询语句中。您还可以使用特定的数据集来查询数据库。</p>
<h3 id="UPDATE"><a href="#UPDATE" class="headerlink" title="UPDATE"></a>UPDATE</h3><p>用于修改表中已有的记录。可以使用带有 WHERE 子句的 UPDATE 查询来更新选定行，否则所有的行都会被更新。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">UPDATE table_name</span><br><span class="line"><span class="keyword">SET</span> col1<span class="operator">=</span>val1, col2<span class="operator">=</span>val2, ... coln<span class="operator">=</span>valn</span><br><span class="line"><span class="keyword">WHERE</span> [<span class="keyword">CONDITION</span>]</span><br></pre></td></tr></table></figure>

<h3 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h3><p>用于删除表中已有的记录。可以使用带有 WHERE 子句的 DELETE 查询来删除选定行，否则所有的记录都会被删除。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> [<span class="keyword">CONDITION</span>]</span><br></pre></td></tr></table></figure>

<h3 id="LIKE"><a href="#LIKE" class="headerlink" title="LIKE"></a>LIKE</h3><p>用来匹配通配符指定模式的文本值。如果搜索表达式与模式表达式匹配，LIKE 运算符将返回真（true），也就是 1。这里有两个通配符与 LIKE 运算符一起使用</p>
<ul>
<li>%：代表<strong>零个或多个</strong>数字或字符。</li>
<li>_：代表<strong>一个</strong>数字或字符。</li>
</ul>
<table>
<thead>
<tr>
<th align="left">语句</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">WHERE salary LIKE ‘200%’</td>
<td align="left">查找以 200 开头的任意值</td>
</tr>
<tr>
<td align="left">WHERE salary LIKE ‘%200%’</td>
<td align="left">查找任意位置包含 200 的任意值</td>
</tr>
<tr>
<td align="left">WHERE salary LIKE ‘_00%’</td>
<td align="left">查找第二位和第三位为 00 的任意值</td>
</tr>
<tr>
<td align="left">WHERE salary LIKE ‘2_%_%’</td>
<td align="left">查找以 2 开头，且长度至少为 3 个字符的任意值</td>
</tr>
<tr>
<td align="left">WHERE salary LIKE ‘%2’</td>
<td align="left">查找以 2 结尾的任意值</td>
</tr>
<tr>
<td align="left">WHERE salary LIKE ‘_2%3’</td>
<td align="left">查找第二位为 2，且以 3 结尾的任意值</td>
</tr>
<tr>
<td align="left">WHERE salary LIKE ‘2___3’</td>
<td align="left">查找长度为 5 位数，且以 2 开头以 3 结尾的任意值</td>
</tr>
</tbody></table>
<h3 id="GLOB"><a href="#GLOB" class="headerlink" title="GLOB"></a>GLOB</h3><p>用来匹配通配符指定模式的文本值。如果搜索表达式与模式表达式匹配，GLOB 运算符将返回真（true），也就是 1。与 LIKE 运算符不同的是，GLOB 是大小写敏感的，对于下面的通配符，它遵循 UNIX 的语法。</p>
<ul>
<li>*：代表<strong>零个或多个</strong>数字或字符。</li>
<li>?：代表<strong>一个</strong>数字或字符。</li>
</ul>
<table>
<thead>
<tr>
<th align="left">语句</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">WHERE salary GLOB ‘200*’</td>
<td align="left">查找以 200 开头的任意值</td>
</tr>
<tr>
<td align="left">WHERE salary GLOB ‘<em>200</em>‘</td>
<td align="left">查找任意位置包含 200 的任意值</td>
</tr>
<tr>
<td align="left">WHERE salary GLOB ‘?00*’</td>
<td align="left">查找第二位和第三位为 00 的任意值</td>
</tr>
<tr>
<td align="left">WHERE salary GLOB ‘2??’</td>
<td align="left">查找以 2 开头，且长度至少为 3 个字符的任意值</td>
</tr>
<tr>
<td align="left">WHERE salary GLOB ‘*2’</td>
<td align="left">查找以 2 结尾的任意值</td>
</tr>
<tr>
<td align="left">WHERE salary GLOB ‘?2*3’</td>
<td align="left">查找第二位为 2，且以 3 结尾的任意值</td>
</tr>
<tr>
<td align="left">WHERE salary GLOB ‘2???3’</td>
<td align="left">查找长度为 5 位数，且以 2 开头以 3 结尾的任意值</td>
</tr>
</tbody></table>
<h3 id="LIMIT"><a href="#LIMIT" class="headerlink" title="LIMIT"></a>LIMIT</h3><p>用于限制由 SELECT 语句返回的数据数量</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> col1, col2, ..., coln</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line">LIMIT [sizeof <span class="keyword">rows</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">or</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> col1, col2, ..., coln</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line">LIMIT [limit_num] <span class="keyword">OFFSET</span> [offset_num]</span><br></pre></td></tr></table></figure>

<h3 id="ORDER-BY"><a href="#ORDER-BY" class="headerlink" title="ORDER BY"></a>ORDER BY</h3><p>用来基于一个或多个列按升序或降序顺序排列数据。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">column</span><span class="operator">-</span>list </span><br><span class="line"><span class="keyword">FROM</span> table_name </span><br><span class="line">[<span class="keyword">WHERE</span> <span class="keyword">condition</span>] </span><br><span class="line">[<span class="keyword">ORDER</span> <span class="keyword">BY</span> column1, column2, .. columnN] [<span class="keyword">ASC</span> <span class="operator">|</span> <span class="keyword">DESC</span>];</span><br></pre></td></tr></table></figure>

<h3 id="GROUP-BY"><a href="#GROUP-BY" class="headerlink" title="GROUP BY"></a>GROUP BY</h3><p>用于与 SELECT 语句一起使用，来对相同的数据进行分组。在 SELECT 语句中，GROUP BY 子句放在 WHERE 子句之后，<strong>放在 ORDER BY 子句之前</strong>。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">column</span><span class="operator">-</span>list</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> [ conditions ]</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> column1, column2....columnN</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> column1, column2....columnN</span><br></pre></td></tr></table></figure>

<h3 id="HAVING"><a href="#HAVING" class="headerlink" title="HAVING"></a>HAVING</h3><p>HAVING 子句允许指定条件来过滤将出现在最终结果中的分组结果。</p>
<p><strong>WHERE 子句在所选列上设置条件，而 HAVING 子句则在由 GROUP BY 子句创建的分组上设置条件。</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, column2</span><br><span class="line"><span class="keyword">FROM</span> table1, table2</span><br><span class="line"><span class="keyword">WHERE</span> [ conditions ]</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> column1, column2</span><br><span class="line"><span class="keyword">HAVING</span> [ conditions ]</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> column1, column2</span><br></pre></td></tr></table></figure>

<h3 id="DISTINCT"><a href="#DISTINCT" class="headerlink" title="DISTINCT"></a>DISTINCT</h3><p>与 SELECT 语句一起使用，来消除所有重复的记录，并只获取唯一一次记录。有可能出现一种情况，在一个表中有多个重复的记录。当提取这样的记录时，DISTINCT 关键字就显得特别有意义，它只获取唯一一次记录，而不是获取重复记录。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> column1, column2,.....columnN </span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> [<span class="keyword">condition</span>]</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Sqlite3</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>sqlite3</tag>
      </tags>
  </entry>
</search>
