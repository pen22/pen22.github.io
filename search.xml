<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hexo</title>
    <url>/2021/05/28/Hexo/</url>
    <content><![CDATA[<h2 id="快速开始-Hexo"><a href="#快速开始-Hexo" class="headerlink" title="快速开始 Hexo"></a>快速开始 Hexo</h2><span id="more"></span>

<h3 id="创建一个新文章"><a href="#创建一个新文章" class="headerlink" title="创建一个新文章"></a>创建一个新文章</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="运行服务器"><a href="#运行服务器" class="headerlink" title="运行服务器"></a>运行服务器</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br><span class="line">$ <span class="comment"># hexo s</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br><span class="line">$ <span class="comment"># hexo g</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="发布到远程网站"><a href="#发布到远程网站" class="headerlink" title="发布到远程网站"></a>发布到远程网站</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br><span class="line">$ <span class="comment">#hexo d</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 126.单词接龙 ||</title>
    <url>/2021/06/21/LeetCode/leetcode-126/</url>
    <content><![CDATA[<h3 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h3><p>给定两个单词（beginWord 和 endWord）和一个字典 wordList，找出所有从 beginWord 到 endWord 的最短转换序列。转换需遵循如下规则：</p>
<p>每次转换只能改变一个字母。<br>转换后得到的单词必须是字典中的单词。<br>说明:</p>
<ul>
<li>如果不存在这样的转换序列，返回一个空列表。</li>
<li>所有单词具有相同的长度。</li>
<li>所有单词只由小写字母组成。</li>
<li>字典中不存在重复的单词。</li>
<li>你可以假设 beginWord 和 endWord 是非空的，且二者不相同。<span id="more"></span>
<h3 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">beginWord = &quot;hit&quot;,</span><br><span class="line">endWord = &quot;cog&quot;,</span><br><span class="line">wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [&quot;hit&quot;,&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;cog&quot;],</span><br><span class="line">  [&quot;hit&quot;,&quot;hot&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">beginWord = &quot;hit&quot;</span><br><span class="line">endWord = &quot;cog&quot;</span><br><span class="line">wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]</span><br><span class="line"></span><br><span class="line">输出: []</span><br><span class="line"></span><br><span class="line">解释: endWord &quot;cog&quot; 不在字典中，所以不存在符合要求的转换序列。</span><br></pre></td></tr></table></figure>

<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>根据题意先将单词表构成一个无向图，然后bfs搜索路径。</p>
<p>这里注意，因为要求返回全部最短路径，所以bfs的队列中单纯的存节点行不通（<del>Maybe可以吧</del>）。</p>
<p>这里我们存路径，也就是<strong>从起点到这个点的路径</strong>，其他的和普通bfs没什么两样。</p>
<p>另外就是时间卡的有点紧，在构图的时候没有那句<code>if(tmp &gt; 1) break;</code>就超时了？？找个时间优化一下算法。</p>
<hr>
<p>( 这个题确实有点让人头大，还是太菜了</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;string&gt;&gt; <span class="built_in">findLadders</span>(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList) &#123;</span><br><span class="line">    <span class="keyword">int</span> n, len, beg, end;</span><br><span class="line">    unordered_map&lt;string, <span class="keyword">int</span>&gt; wti;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; G;  </span><br><span class="line">    vector&lt;string&gt; words;  <span class="comment">//拷贝单词表</span></span><br><span class="line"></span><br><span class="line">    n = wordList.<span class="built_in">size</span>(); <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    len = wordList[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    words = wordList;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        wti[words[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!wti.<span class="built_in">count</span>(endWord)) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    <span class="keyword">if</span>(!wti.<span class="built_in">count</span>(beginWord)) &#123; words.<span class="built_in">push_back</span>(beginWord); wti[beginWord] = n++; &#125;</span><br><span class="line">    </span><br><span class="line">    beg = wti[beginWord];</span><br><span class="line">    end = wti[endWord];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构图</span></span><br><span class="line">    G.<span class="built_in">resize</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; len; k++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(words[i][k] != words[j][k]) tmp++;</span><br><span class="line">                <span class="keyword">if</span>(tmp &gt; <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(tmp == <span class="number">1</span>) &#123;</span><br><span class="line">                G[i].<span class="built_in">push_back</span>(j);</span><br><span class="line">                G[j].<span class="built_in">push_back</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; ans;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//搜路</span></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dis</span><span class="params">(n, <span class="number">0x3f3f3f</span>)</span></span>;</span><br><span class="line">    dis[beg] = <span class="number">0</span>;</span><br><span class="line">    queue&lt;vector&lt;string&gt;&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;beginWord&#125;);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        vector&lt;string&gt; path = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">int</span> u = wti[path.<span class="built_in">back</span>()];</span><br><span class="line">        <span class="keyword">if</span>(u == end) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> v : G[u]) &#123;</span><br><span class="line">                <span class="keyword">if</span>(dis[u] + <span class="number">1</span> &lt;= dis[v]) &#123;</span><br><span class="line">                    vector&lt;string&gt; tmp = path;</span><br><span class="line">                    tmp.<span class="built_in">push_back</span>(words[v]);</span><br><span class="line">                    q.<span class="built_in">push</span>(tmp);</span><br><span class="line">                    dis[v] = dis[u] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>搜索</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 128.最长连续序列</title>
    <url>/2021/06/22/LeetCode/leetcode-128/</url>
    <content><![CDATA[<h3 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h3><p>给定一个未排序的整数数组，找出最长连续序列的长度。</p>
<p>要求算法的**时间复杂度为 O(n)**。</p>
<span id="more"></span>
<h3 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [100, 4, 200, 1, 3, 2]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 最长连续序列是 [1, 2, 3, 4]。它的长度为 4。</span><br></pre></td></tr></table></figure>

<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>要求时间复杂度为 $O(n)$ 自然是<strong>不能排序</strong>了，并查集可以把<strong>属性相似的一类数聚在一起的作用</strong>，而且压缩后的并查集时间复杂度也很可观。</p>
<ul>
<li><p>先初始化数组中每一个数指向本身。</p>
</li>
<li><p>循环数组</p>
<ul>
<li><p>如果 $nums[i] + 1$ 在并查集中， $nums[i] + 1$ 指向 $nums[i]$。</p>
</li>
<li><p>如果 $nums[i] - 1$ 在并查集中， $nums[i]$ 指向 $nums[i] - 1$。</p>
</li>
</ul>
</li>
</ul>
<p><strong>⚠这题依然有个空数组问题，又被坑了。。。</strong></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; p;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x == p[x] ? x : p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.<span class="built_in">size</span>(); <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> item : nums) &#123; p[item] = item; &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> item : nums) &#123;</span><br><span class="line">        <span class="keyword">if</span>(p.<span class="built_in">count</span>(item + <span class="number">1</span>)) p[item + <span class="number">1</span>] = item;</span><br><span class="line">        <span class="keyword">if</span>(p.<span class="built_in">count</span>(item - <span class="number">1</span>)) p[item] = item - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> item : nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="built_in">find</span>(item);</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, item - temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 238.除自身以外数组的乘积</title>
    <url>/2021/06/22/LeetCode/leetcode-238/</url>
    <content><![CDATA[<h3 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h3><p>给你一个长度为 n 的整数数组 nums，其中 n &gt; 1，返回输出数组 output ，其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。</p>
<p><strong>提示</strong>：题目数据保证数组之中任意元素的全部前缀元素和后缀（甚至是整个数组）的乘积都在 32 位整数范围内。</p>
<p><strong>说明</strong>: 请不要使用除法，且在 O(n) 时间复杂度内完成此题。</p>
<p><strong>进阶</strong>：你可以在常数空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组不被视为额外空间。)</p>
<span id="more"></span>
<h3 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3,4]</span><br><span class="line">输出: [24,12,8,6]</span><br></pre></td></tr></table></figure>

<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul>
<li><p>常规做法<br>  一看到的一下子想到的可能就是把所有数累乘起来，然后<strong>循环</strong>一边，循环到那个数就<strong>除掉</strong>哪个数。但是注意如果这个题是累加的话可以这样做，但是这个题是累乘，如果有一个位置是0，这时候就会出错。</p>
<p>  所以考虑另一种方法，将数组做一次<strong>前缀和后缀累乘</strong>，循环到某个数的时候将该数<strong>前缀乘以后缀</strong>即可</p>
</li>
<li><p>进阶做法<br>  在进阶里面要求到常数空间复杂度，如果是按照常规做法，需要用到<strong>left和right</strong>两个数组分别存<strong>前缀和后缀</strong>，另外还得开一个答案数组去存储计算答案。这样空间复杂度明显是 $O(n)$ ，因为题目要求中讲到</p>
<blockquote>
<p>出于对空间复杂度分析的目的，输出数组不被视为额外空间。</p>
</blockquote>
<p>  也就是常数空间复杂度的话就需要把答案数组拿进来<strong>重新利用</strong>，于是可以想到如下做法</p>
<blockquote>
<p>假设nums[] = {a, b, c, d}<br>  令ans[] = {1, a, ab, abc}<br>  然后倒着计算一边ans数组使得<br>  ans[] = {1 * bcd, a * cd, ab * d, abc}</p>
</blockquote>
<p>  这不刚好就是答案吗。这个题的做法就出来了</p>
</li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><ul>
<li><p>常规做法</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">productExceptSelf</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">left</span><span class="params">(n)</span>, <span class="title">right</span><span class="params">(n)</span>, <span class="title">ans</span><span class="params">(n)</span></span>;</span><br><span class="line">    </span><br><span class="line">    left[<span class="number">0</span>] = nums[<span class="number">0</span>]; right[n - <span class="number">1</span>] = nums[n - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123; left[i] = nums[i] * left[i - <span class="number">1</span>]; &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123; right[i] = nums[i] * right[i + <span class="number">1</span>]; &#125;</span><br><span class="line">    </span><br><span class="line">    ans[<span class="number">0</span>] = right[<span class="number">1</span>]; ans[n - <span class="number">1</span>] = left[n - <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        ans[i] = left[i - <span class="number">1</span>] * right[i + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>进阶做法</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">productExceptSelf</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123; </span><br><span class="line">        ans[i] = ans[i - <span class="number">1</span>] * nums[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> tmp = nums[n - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        ans[i] *= tmp;</span><br><span class="line">        tmp *= nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 15.新21点</title>
    <url>/2021/06/20/LeetCode/leetcode-15/</url>
    <content><![CDATA[<h3 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h3><p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。</p>
<p><strong>注意</strong>：答案中不可以包含重复的三元组。</p>
<span id="more"></span>
<h3 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [-1, 0, 1, 2, -1, 4]</span><br><span class="line">输出：ans = [[-1, 0, 1], [-1, -1, 2]]</span><br></pre></td></tr></table></figure>

<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>排序+双指针+vector数组去重，去重有两种方式🙂</p>
<ul>
<li><p>vector + set去重<br><code>set&lt;vector&lt;int&gt;&gt; s(ans.begin(), ans.end());</code><br><code>ans.assign(s.begin(), s.end());</code></p>
<p>  过是可以过，但是….<br>  <a href="https://imgtu.com/i/RuxDV1"><img src="https://z3.ax1x.com/2021/06/23/RuxDV1.png" alt="RuxDV1.png"></a></p>
</li>
<li><p>第二种就是在代码里面去重，如果碰到重复的就跳过，这个不算太差..<br>  <a href="https://imgtu.com/i/Rux0bR"><img src="https://z3.ax1x.com/2021/06/23/Rux0bR.png" alt="Rux0bR.png"></a></p>
</li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span>(nums.<span class="built_in">size</span>() &lt; <span class="number">3</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">2</span> &amp;&amp; nums[i] &lt;= <span class="number">0</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> l = i + <span class="number">1</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = nums[i] + nums[l] + nums[r];</span><br><span class="line">            <span class="keyword">if</span>(tmp &gt; <span class="number">0</span>) r--;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(tmp &lt; <span class="number">0</span>) l++;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">while</span>(l &lt; r &amp;&amp; nums[l] == nums[l + <span class="number">1</span>]) l++;</span><br><span class="line">                <span class="keyword">while</span>(l &lt; r &amp;&amp; nums[r] == nums[r - <span class="number">1</span>]) r--;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(&#123;nums[i], nums[l], nums[r]&#125;);</span><br><span class="line">                l++; r--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 29.顺时针打印矩阵</title>
    <url>/2021/06/21/LeetCode/leetcode-29/</url>
    <content><![CDATA[<h3 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h3><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p>
<span id="more"></span>
<h3 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">输出：[1,2,3,6,9,8,7,4,5]</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]</span><br><span class="line">输出：[1,2,3,4,8,12,11,10,9,5,6,7]</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 &lt;= matrix.length &lt;= 100</span><br><span class="line">0 &lt;= matrix[i].length &lt;= 100</span><br></pre></td></tr></table></figure>

<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>直接按照题意转就好了，这道题虽然标的Easy，但还是被<strong>空向量</strong>和<strong>数据范围不明确</strong>给坑了一下。。</p>
<p>没有数据范围，我直接把访问过的地方标记 $0x3f3f3f3f$ 但其实这种做法是不对的，正确的做法是使用另一个 $vis$ 数组，$vis[i][j]$ 表示$i,j$ 这个位置输出过了。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ok</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> &lt;= x &amp;&amp; x &lt; n &amp;&amp; <span class="number">0</span> &lt;= y &amp;&amp; y &lt; m;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">spiralOrder</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = matrix.<span class="built_in">size</span>(); <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    <span class="keyword">int</span> m = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(n * m)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>, tmp = <span class="number">0</span>, inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> d[<span class="number">4</span>][<span class="number">2</span>] = &#123; &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125; &#125;;</span><br><span class="line">    ans[cnt++] = matrix[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    matrix[x][y] = inf;</span><br><span class="line">    <span class="keyword">while</span>(cnt &lt; n * m) &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">ok</span>(x + d[tmp][<span class="number">0</span>], y + d[tmp][<span class="number">1</span>], n, m) &amp;&amp; matrix[x + d[tmp][<span class="number">0</span>]][y + d[tmp][<span class="number">1</span>]] != inf) &#123;</span><br><span class="line">            ans[cnt++] = matrix[x + d[tmp][<span class="number">0</span>]][y + d[tmp][<span class="number">1</span>]];</span><br><span class="line">            matrix[x + d[tmp][<span class="number">0</span>]][y + d[tmp][<span class="number">1</span>]] = inf;</span><br><span class="line">            x += d[tmp][<span class="number">0</span>];</span><br><span class="line">            y += d[tmp][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        tmp = (tmp + <span class="number">1</span>) % <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 42.连续子数组的最大和</title>
    <url>/2021/06/21/LeetCode/leetcode-42/</url>
    <content><![CDATA[<h3 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h3><p>输入一个整型数组，数组里有正数也有负数。数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。</p>
<p>要求<strong>时间复杂度</strong>为 $O(n)$ 。</p>
<span id="more"></span>
<h3 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class="line">输出: 6</span><br><span class="line">解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 &lt;= arr.length &lt;= 10^5</span><br><span class="line">-100 &lt;= arr[i] &lt;= 100</span><br></pre></td></tr></table></figure>

<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p><strong>状态定义</strong>：$dp[i]$ = 以$nums[i]$为结尾的连续子数组的和的最大值</p>
<p><strong>转移方程</strong>：若 $dp[i-1] \leq 0$ ，说明 $dp[i−1]$ 对 $dp[i]$ 产生负贡献，即 $dp[i-1] + nums[i]$ 还不如 $nums[i]$ 本身大。</p>
<ul>
<li><p>当 $dp[i-1] \leq 0$，$dp[i]=nums[i]$</p>
</li>
<li><p>当 $dp[i-1]&gt;0$，$dp[i] = dp[i-1]+nums[i]$</p>
</li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> ans = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        dp[i] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>] + nums[i], nums[i]);</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, dp[i]); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 837.新21点</title>
    <url>/2021/06/22/LeetCode/leetcode-837/</url>
    <content><![CDATA[<h3 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h3><p>爱丽丝参与一个大致基于纸牌游戏 “21点” 规则的游戏，描述如下：</p>
<p>爱丽丝以 0 分开始，并在她的得分少于 K 分时抽取数字。 抽取时，她从 [1, W] 的范围中随机获得一个整数作为分数进行累计，其中 W 是整数。 每次抽取都是独立的，其结果具有相同的概率。</p>
<p>当爱丽丝获得不少于 K 分时，她就停止抽取数字。 爱丽丝的分数不超过 N 的概率是多少？</p>
<span id="more"></span>
<h3 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：N = 10, K = 1, W = 10</span><br><span class="line">输出：1.00000</span><br><span class="line">说明：爱丽丝得到一张卡，然后停止。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：N = 6, K = 1, W = 10</span><br><span class="line">输出：0.60000</span><br><span class="line">说明：爱丽丝得到一张卡，然后停止。</span><br><span class="line">在 W = 10 的 6 种可能下，她的得分不超过 N = 6 分。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：N = 21, K = 17, W = 10</span><br><span class="line">输出：0.73278</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 0 &lt;= K &lt;= N &lt;= 10000</span><br><span class="line">2. 1 &lt;= W &lt;= 10000</span><br><span class="line">3. 如果答案与正确答案的误差不超过 10^-5，则该答案将被视为正确答案通过。</span><br></pre></td></tr></table></figure>

<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>定义这样的<strong>dp数组</strong><br>$$dp[i] = 令初始分数为i，抽牌结束后不超过N的概率$$</p>
<p>初始化 $dp$ 数组的时候 $dp[i]=1,i \in [K,N]$ $dp[i]=0,i \in (N,+ \infty )$ </p>
<p>当<strong>初始分数</strong>为 $K-1$ 时，很明显知道<strong>概率</strong>为 $P= \frac{\sum_{i=K}^{K+W} dp[i]}{W}$ ，这时顺着公式从k-1推回0即可。</p>
<p>但是这里注意一下数据范围，如果是这样先循环一个 $K$ ，再循环 $W$ ，时间复杂度会很高所以在处理的时候注意一下那一段 $\sum_{i=K}^{K+W} dp[i]$ ，<strong>计算的时候可以减去区间后面的，再加上区间前面的。</strong></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">new21Game</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> K, <span class="keyword">int</span> W)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">double</span>&gt; <span class="title">dp</span><span class="params">(N + W + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = K; i &lt;= N; i++) dp[i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">double</span> tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = K + <span class="number">1</span>; i &lt;= K + W; i++) tmp += dp[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = K - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        tmp += dp[i + <span class="number">1</span>];</span><br><span class="line">        tmp -= dp[i + <span class="number">1</span> + W];</span><br><span class="line">        dp[i] = tmp / W;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 64.求1+2+...+n</title>
    <url>/2021/06/21/LeetCode/leetcode-64/</url>
    <content><![CDATA[<h3 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h3><ul>
<li>求 1+2+…+n ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。<span id="more"></span>
<h3 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: n = 3</span><br><span class="line">输出: 6</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: n = 9</span><br><span class="line">输出: 45</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>可以先思考通过求和公式 <code>n * (n + 1) &gt;&gt; 1</code> 但这种方式必须要用乘法，不然的话需要<code>if</code>来做判断，在偶数那里 <code> &gt;&gt; 1</code> ，所以这个思路会行不通。</p>
<p>通过循环来求和 <code>while(n) sum += (n--);</code> 但是会用到<code>while</code>可这已经很精简了，没有用到乘除法只是多了一个while，while又可以通过递归消掉。</p>
<ul>
<li>思考如何去掉while循环，这里要明确一点，在 <code>C/C++</code> 中<code>&amp;&amp;</code>和<code>||</code>操作并不是对两个操作数都去判断一下，<strong>而是当<code>&amp;&amp;</code>, <code>||</code>第一个操作数就已经满足条件的情况下不会再去判断第二个操作数了</strong>，利用这一点可以作为递归的边界判断。<br>  假设当前循环到了 $x$<ul>
<li><code>!x || (sum += x)</code> 表示当 $x$ 达到<strong>向下</strong>循环边界 0 时返回 <code>false</code>，这时递归停止</li>
<li><code>x &amp;&amp; （sum += x)</code> 表示当 $x$ 达到<strong>向下</strong>循环边界 0 时返回 <code>false</code>，递归停止</li>
<li><code>x ^ n</code> 表示当 $x$ 达到<strong>向上</strong>循环边界 n 时递归停止，但是这种方法需要另一个函数的配合</li>
</ul>
</li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><ul>
<li>3种</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sumNums</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    !n || (n += <span class="built_in">sumNums</span>(n - <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sumNums</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    n &amp;&amp; (n += <span class="built_in">sumNums</span>(n - <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">subSum</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    (x ^ n) &amp;&amp; (x += <span class="built_in">subSum</span>(x + <span class="number">1</span>, n));</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sumNums</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">subSum</span>(<span class="number">1</span>, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2020/06/02/Og8FAjvZ6pR2SKQ.png" alt="leetcode6-2_2.png"></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>mongoose API参考</title>
    <url>/2021/08/01/mongoose-API%E5%8F%82%E8%80%83/</url>
    <content><![CDATA[<h3 id="通用API"><a href="#通用API" class="headerlink" title="通用API"></a>通用API</h3><span id="more"></span>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">http_message</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mg_str</span> <span class="title">message</span>;</span> <span class="comment">/* Whole message: request line + headers + body */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mg_str</span> <span class="title">body</span>;</span>    <span class="comment">/* Message body. 0-length for requests with no body */</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* HTTP Request line (or HTTP response line) */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mg_str</span> <span class="title">method</span>;</span> <span class="comment">/* &quot;GET&quot; */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mg_str</span> <span class="title">uri</span>;</span>    <span class="comment">/* &quot;/my_file.html&quot; */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mg_str</span> <span class="title">proto</span>;</span>  <span class="comment">/* &quot;HTTP/1.1&quot; -- for both request and response */</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* For responses, code and response status message are set */</span></span><br><span class="line">  <span class="keyword">int</span> resp_code;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mg_str</span> <span class="title">resp_status_msg</span>;</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * Query-string part of the URI. For example, for HTTP request</span></span><br><span class="line"><span class="comment">   *    GET /foo/bar?param1=val1&amp;param2=val2</span></span><br><span class="line"><span class="comment">   *    |    uri    |     query_string     |</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * Note that question mark character doesn&#x27;t belong neither to the uri,</span></span><br><span class="line"><span class="comment">   * nor to the query_string</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mg_str</span> <span class="title">query_string</span>;</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Headers */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mg_str</span> <span class="title">header_names</span>[<span class="title">MG_MAX_HTTP_HEADERS</span>];</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mg_str</span> <span class="title">header_values</span>[<span class="title">MG_MAX_HTTP_HEADERS</span>];</span></span><br><span class="line">&#125;;<span class="comment">///HTTP消息</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">websocket_message</span> &#123;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> *data;</span><br><span class="line">  <span class="keyword">size_t</span> size;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> flags;</span><br><span class="line">&#125;;<span class="comment">///websocket消息</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mg_http_multipart_part</span> &#123;</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *file_name;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *var_name;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mg_str</span> <span class="title">data</span>;</span></span><br><span class="line">  <span class="keyword">int</span> status; <span class="comment">/* &lt;0 on error */</span></span><br><span class="line">  <span class="keyword">void</span> *user_data;</span><br><span class="line">&#125;;<span class="comment">///HTTP分包部分</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mg_ssi_call_ctx</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">http_message</span> *<span class="title">req</span>;</span> <span class="comment">/* The request being processed. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mg_str</span> <span class="title">file</span>;</span>       <span class="comment">/* Filesystem path of the file being processed. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mg_str</span> <span class="title">arg</span>;</span> <span class="comment">/* The argument passed to the tag: &lt;!-- call arg --&gt;. */</span></span><br><span class="line">&#125;;<span class="comment">///SSI调用上下文</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mg_set_protocol_http_websocket</span><span class="params">(struct mg_connection *nc)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mg_send_websocket_handshake</span><span class="params">(struct mg_connection *nc, <span class="keyword">const</span> <span class="keyword">char</span> *uri,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 <span class="keyword">const</span> <span class="keyword">char</span> *extra_headers)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mg_send_websocket_handshake2</span><span class="params">(struct mg_connection *nc, <span class="keyword">const</span> <span class="keyword">char</span> *path,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="keyword">const</span> <span class="keyword">char</span> *host, <span class="keyword">const</span> <span class="keyword">char</span> *protocol,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="keyword">const</span> <span class="keyword">char</span> *extra_headers)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mg_send_websocket_handshake3</span><span class="params">(struct mg_connection *nc, <span class="keyword">const</span> <span class="keyword">char</span> *path,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="keyword">const</span> <span class="keyword">char</span> *host, <span class="keyword">const</span> <span class="keyword">char</span> *protocol,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="keyword">const</span> <span class="keyword">char</span> *extra_headers, <span class="keyword">const</span> <span class="keyword">char</span> *user,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="keyword">const</span> <span class="keyword">char</span> *pass)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mg_send_websocket_handshake3v</span><span class="params">(struct mg_connection *nc,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   <span class="keyword">const</span> struct mg_str path,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   <span class="keyword">const</span> struct mg_str host,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   <span class="keyword">const</span> struct mg_str protocol,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   <span class="keyword">const</span> struct mg_str extra_headers,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   <span class="keyword">const</span> struct mg_str user,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   <span class="keyword">const</span> struct mg_str pass)</span></span>;</span><br><span class="line"><span class="function">struct mg_connection *<span class="title">mg_connect_ws</span><span class="params">(struct mg_mgr *mgr,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    MG_CB(<span class="keyword">mg_event_handler_t</span> event_handler,</span></span></span><br><span class="line"><span class="params"><span class="function">                                          <span class="keyword">void</span> *user_data),</span></span></span><br><span class="line"><span class="params"><span class="function">                                    <span class="keyword">const</span> <span class="keyword">char</span> *url, <span class="keyword">const</span> <span class="keyword">char</span> *protocol,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    <span class="keyword">const</span> <span class="keyword">char</span> *extra_headers)</span></span>;</span><br><span class="line"><span class="function">struct mg_connection *<span class="title">mg_connect_ws_opt</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    struct mg_mgr *mgr, MG_CB(<span class="keyword">mg_event_handler_t</span> ev_handler, <span class="keyword">void</span> *user_data),</span></span></span><br><span class="line"><span class="params"><span class="function">    struct mg_connect_opts opts, <span class="keyword">const</span> <span class="keyword">char</span> *url, <span class="keyword">const</span> <span class="keyword">char</span> *protocol,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> <span class="keyword">char</span> *extra_headers)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mg_send_websocket_frame</span><span class="params">(struct mg_connection *nc, <span class="keyword">int</span> op_and_flags,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="keyword">const</span> <span class="keyword">void</span> *data, <span class="keyword">size_t</span> data_len)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mg_send_websocket_framev</span><span class="params">(struct mg_connection *nc, <span class="keyword">int</span> op_and_flags,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="keyword">const</span> struct mg_str *strings, <span class="keyword">int</span> num_strings)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mg_printf_websocket_frame</span><span class="params">(struct mg_connection *nc, <span class="keyword">int</span> op_and_flags,</span></span></span><br><span class="line"><span class="params"><span class="function">                               <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mg_url_decode</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *src, <span class="keyword">int</span> src_len, <span class="keyword">char</span> *dst, <span class="keyword">int</span> dst_len,</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="keyword">int</span> is_form_url_encoded)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">mg_hash_md5_v</span><span class="params">(<span class="keyword">size_t</span> num_msgs, <span class="keyword">const</span> <span class="keyword">uint8_t</span> *msgs[],</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="keyword">const</span> <span class="keyword">size_t</span> *msg_lens, <span class="keyword">uint8_t</span> *digest)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">mg_hash_sha1_v</span><span class="params">(<span class="keyword">size_t</span> num_msgs, <span class="keyword">const</span> <span class="keyword">uint8_t</span> *msgs[],</span></span></span><br><span class="line"><span class="params"><span class="function">                           <span class="keyword">const</span> <span class="keyword">size_t</span> *msg_lens, <span class="keyword">uint8_t</span> *digest)</span></span>;</span><br></pre></td></tr></table></figure>



<h3 id="HTTP-Server端API"><a href="#HTTP-Server端API" class="headerlink" title="HTTP Server端API"></a>HTTP Server端API</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mg_parse_http</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">int</span> n, struct http_message *hm, <span class="keyword">int</span> is_req)</span></span>;</span><br><span class="line"><span class="comment">/**解析http消息，如果is_req=1 此消息是http请求，is_req=0 此消息是http回应</span></span><br><span class="line"><span class="comment"> *返回解析的字节数 如果http消息不完整则返回0 如果解析出错，则返回负数*/</span></span><br><span class="line"><span class="function">struct mg_str *<span class="title">mg_get_http_header</span><span class="params">(struct http_message *hm, <span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br><span class="line"><span class="comment">/**搜索并返回解析后的http消息hm中的表头名称，如果没有找到标头，则返回NULL</span></span><br><span class="line"><span class="comment"> *实例：struct mg_str *host_hdr = mg_get_http_header(hm, &quot;Host&quot;);*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mg_http_parse_header</span><span class="params">(struct mg_str *hdr, <span class="keyword">const</span> <span class="keyword">char</span> *var_name, <span class="keyword">char</span> *buf,</span></span></span><br><span class="line"><span class="params"><span class="function">                         <span class="keyword">size_t</span> buf_size)</span></span>;</span><br><span class="line"><span class="comment">/**解析http头hdr,查找变量var_name并将其值存储到buf中，如果没有找到变量，返回0否则返回非0。此函数用于解析cookies验证头等。如果成功则返回变量值的长度，如果buf缓冲区不够大，或者没有找到此变量则返回0</span></span><br><span class="line"><span class="comment">char user[20];</span></span><br><span class="line"><span class="comment">struct mg_str *hdr = mg_get_http_header(hm, &quot;Authorization&quot;);</span></span><br><span class="line"><span class="comment">mg_http_parse_header(hdr, &quot;username&quot;, user, sizeof(user));</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mg_get_http_basic_auth</span><span class="params">(struct http_message *hm, <span class="keyword">char</span> *user, <span class="keyword">size_t</span> user_len,</span></span></span><br><span class="line"><span class="params"><span class="function">                           <span class="keyword">char</span> *pass, <span class="keyword">size_t</span> pass_len)</span></span>;</span><br><span class="line"><span class="comment">/*获取并解析授权，如果没有找到授权头或者mg_parse_http_basic_auth解析结果头失败*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mg_parse_http_basic_auth</span><span class="params">(struct mg_str *hdr, <span class="keyword">char</span> *user, <span class="keyword">size_t</span> user_len,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="keyword">char</span> *pass, <span class="keyword">size_t</span> pass_len)</span></span>;</span><br><span class="line"><span class="comment">/*解析授权,如授权类型不是Basic或者出现其他错误(如用于base64编码的用户密码不对)基本头返回-1*/</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">mg_parse_multipart</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> buf_len, <span class="keyword">char</span> *var_name,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="keyword">size_t</span> var_name_len, <span class="keyword">char</span> *file_name,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="keyword">size_t</span> file_name_len, <span class="keyword">const</span> <span class="keyword">char</span> **chunk,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="keyword">size_t</span> *chunk_len)</span></span>;</span><br><span class="line"><span class="comment">/*解析包含多部分表单数据库的缓冲区buf,buf_len,将块名存储在var_name,var_name_len缓冲区中。如果块是上传文件，那么file_name,file_name_len将会被一个上传的文件名填充。chunk,chunk_len指向块数据。返回要跳到下一个块的字节数，如果没有更多块则返回0*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mg_get_http_var</span><span class="params">(<span class="keyword">const</span> struct mg_str *buf, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">char</span> *dst,</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="keyword">size_t</span> dst_len)</span></span>;</span><br><span class="line"><span class="comment">/*获取Http表单变量。从buf获取变量名，到指定dst指定长度dst_len的缓冲区。目的地址总是0终止，返回获取到的变量的长度，如果没有找到变量，则返回0.buf必须是有效的url编码缓冲区。如果dst长度太小或者发生错误返回负数*/</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//此结构定义了mg_serve_http()的工作方式，最佳是设置需要的，其余为NULL</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mg_serve_http_opts</span> &#123;</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *document_root;<span class="comment">///web根目录路径</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *index_files;<span class="comment">///索引文件列表，默认是&quot;&quot;</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  per_directory_auth_file =NULL表示禁用身份验证</span></span><br><span class="line"><span class="comment">  per_directory_auth_file =&quot;.htpasswd&quot; 要使用身份认证来保护目录，然后在任何目录创建使用                                 digest认证的.htpasswd文件。使用mongoose web服务器二进制文件或                             者Apache的htpasswd实例创建/操作密码文件</span></span><br><span class="line"><span class="comment">                             确保auth_domain是一个有效的域</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *per_directory_auth_file;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *auth_domain;<span class="comment">//授权域。即web服务器的域名</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">      global_auth_file = NULL 禁用身份认证</span></span><br><span class="line"><span class="comment">      通常只保护document_root根目录选定的目录。如果对web服务器的所有访问都必须经过身份验证，       不管URI是什么，将此选项设置为密码文件的路径。此文件的格式与.htpasswd的格式一样，并把此        文件放在document_root根目录之外，以防他人获取到此文件</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *global_auth_file;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *enable_directory_listing;<span class="comment">//设置为&quot;no&quot;禁用目录列表，默认启用</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *ssi_pattern;<span class="comment">///ssi匹配模式  源码有详细介绍</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *ip_acl;<span class="comment">///ip_acl=NULL表示所有IP都可链接</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> MG_ENABLE_HTTP_URL_REWRITES</span></span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">char</span> *url_rewrites;/源码有详细介绍</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *dav_document_root;<span class="comment">///DAV的根目录,dav_document_root=NULL 则DAV请求失败</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *dav_auth_file;<span class="comment">//DAV密码文件，dav_auth_file=NULL 则DAV请求失败 dav_auth_file=&quot;-&quot; 禁用DAV鉴权</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *hidden_file_pattern;<span class="comment">///文件隐藏的Glob模式</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *cgi_file_pattern;<span class="comment">///cgi_file_pattern != NULL 则使能cgi，即此目录下满足 **.cgi$|**.php$&quot;都视为cgi文件</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *cgi_interpreter;<span class="comment">///如果不是NULL，请忽略CGI脚本hashbang并使用这个解释器</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *custom_mime_types;</span><br><span class="line"><span class="comment">/*Comma-separated list of Content-Type overrides for path suffixes,&quot;.txt=text/plain; charset=utf-8,.c=text/plain&quot;e.g.*/</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *extra_headers;<span class="comment">///添加到每个http相应的额外的header,要启用CORS，请将此设置为&quot;Access-Control-Allow-Origin: *&quot;。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mg_serve_http</span><span class="params">(struct mg_connection *nc, struct http_message *hm,</span></span></span><br><span class="line"><span class="params"><span class="function">                   struct mg_serve_http_opts opts)</span></span>;</span><br><span class="line"><span class="comment">/*根据opts的内容，提供特定的http请求*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mg_http_serve_file</span><span class="params">(struct mg_connection *nc, struct http_message *hm,</span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> struct mg_str mime_type,</span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="keyword">const</span> struct mg_str extra_headers)</span></span>;</span><br><span class="line"><span class="comment">/*提供具有给定MIME类型和可选extra_headers头的特定文件*/</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> struct <span class="title">mg_str</span> <span class="params">(*mg_fu_fname_fn)</span><span class="params">(struct mg_connection *nc,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        struct mg_str fname)</span></span>;<span class="comment">///mg_file_upload_handler()的回调函数原型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mg_file_upload_handler</span><span class="params">(struct mg_connection *nc, <span class="keyword">int</span> ev, <span class="keyword">void</span> *ev_data,</span></span></span><br><span class="line"><span class="params"><span class="function">                            mg_fu_fname_fn local_name_fn</span></span></span><br><span class="line"><span class="params"><span class="function">                                MG_UD_ARG(<span class="keyword">void</span> *user_data))</span></span>;</span><br><span class="line"><span class="comment">/*文件上传处理程序。这个处理程序可以用最少的代码实现文件上传.此程序处理MG_EV_HTTPPART事件并保存文件数据到本地。local_name_fn将以客户端提供的名字调用并以期望的本地文件名称打开。如果返回NULL将终止文件上传(客户端得到403)，如果返回不是NULL,返回的字符串必须是堆分配的，且调用方需要释放这些字符串。异常情况：返回完全相同的字符串，</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mg_register_http_endpoint</span><span class="params">(struct mg_connection *nc, <span class="keyword">const</span> <span class="keyword">char</span> *uri_path,</span></span></span><br><span class="line"><span class="params"><span class="function">                               MG_CB(<span class="keyword">mg_event_handler_t</span> handler,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     <span class="keyword">void</span> *user_data))</span></span>;</span><br><span class="line"><span class="comment">/*为nc注册回调函数，如果注册了回调函数，其会被调用欧冠，而不是调用mg_bind()中提供的回调函数*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mg_http_endpoint_opts</span> &#123;</span></span><br><span class="line">  <span class="keyword">void</span> *user_data;</span><br><span class="line">  <span class="comment">/*授权域 (realm) */</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *auth_domain;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *auth_file;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mg_register_http_endpoint_opt</span><span class="params">(struct mg_connection *nc,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   <span class="keyword">const</span> <span class="keyword">char</span> *uri_path,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   <span class="keyword">mg_event_handler_t</span> handler,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   struct mg_http_endpoint_opts opts)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mg_http_check_digest_auth</span><span class="params">(struct http_message *hm, <span class="keyword">const</span> <span class="keyword">char</span> *auth_domain,</span></span></span><br><span class="line"><span class="params"><span class="function">                              FILE *fp)</span></span>;</span><br><span class="line"><span class="comment">/*根据打开的密码文件验证HTTP请求。如果经过身份验证，返回1，否则返回0*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mg_check_digest_auth</span><span class="params">(struct mg_str method, struct mg_str uri,</span></span></span><br><span class="line"><span class="params"><span class="function">                         struct mg_str username, struct mg_str cnonce,</span></span></span><br><span class="line"><span class="params"><span class="function">                         struct mg_str response, struct mg_str qop,</span></span></span><br><span class="line"><span class="params"><span class="function">                         struct mg_str nc, struct mg_str nonce,</span></span></span><br><span class="line"><span class="params"><span class="function">                         struct mg_str auth_domain, FILE *fp)</span></span>;</span><br><span class="line"><span class="comment">/*对打开的密码文件验证给定的响应参数。如果经过身份验证，返回1，否则返回0。</span></span><br><span class="line"><span class="comment">由 mg_http_check_digest_auth().调用</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mg_send_http_chunk</span><span class="params">(struct mg_connection *nc, <span class="keyword">const</span> <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> len)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">使用组块HTTP编码向客户端发送大小为len的缓冲区buf.这个函数首先将  发送缓冲区大小(16进制)+换行符+缓冲区+换行符发出。例如，mg_send_http_chunk(nc，“foo”，3)将把 &quot;3\r\nfoo\r\n&quot;字符串追加到nc-&gt;send_mbuf输出IO缓冲区</span></span><br><span class="line"><span class="comment">HTTP头“传输编码:块化”应该在使用此函数之前发送</span></span><br><span class="line"><span class="comment">不要忘记在响应结束时发送一个空块，告诉客户端所有内容都已发送</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mg_printf_http_chunk</span><span class="params">(struct mg_connection *nc, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span></span>;</span><br><span class="line"><span class="comment">/*发送一个printf格式的HTTP块。功能类似于mg_send_http_chunk()。*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mg_send_response_line</span><span class="params">(struct mg_connection *nc, <span class="keyword">int</span> status_code,</span></span></span><br><span class="line"><span class="params"><span class="function">                           <span class="keyword">const</span> <span class="keyword">char</span> *extra_headers)</span></span>;</span><br><span class="line"><span class="comment">/*发送响应状态行。如果extra_headers不是NULL，那么extra_headers也会在响应行之后发送。extra_headers不能以新行结束*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mg_http_send_error</span><span class="params">(struct mg_connection *nc, <span class="keyword">int</span> code, <span class="keyword">const</span> <span class="keyword">char</span> *reason)</span></span>;</span><br><span class="line"><span class="comment">/*发送一个错误的回应。如果原因为空，消息将从错误代码中推断出来(如果支持的话)*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mg_http_send_redirect</span><span class="params">(struct mg_connection *nc, <span class="keyword">int</span> status_code,</span></span></span><br><span class="line"><span class="params"><span class="function">                           <span class="keyword">const</span> struct mg_str location,</span></span></span><br><span class="line"><span class="params"><span class="function">                           <span class="keyword">const</span> struct mg_str extra_headers)</span></span>;</span><br><span class="line"><span class="comment">/*发送一个重定向响应。status_code应该是301或302，位置指向新位置。如果extra_headers不是空的，那么extra_headers也会在响应行之后发送。extra_headers不能以新行结束。*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mg_send_head</span><span class="params">(struct mg_connection *n, <span class="keyword">int</span> status_code,</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="keyword">int64_t</span> content_length, <span class="keyword">const</span> <span class="keyword">char</span> *extra_headers)</span></span>;</span><br><span class="line"><span class="comment">/*发送响应行和标题。这个函数用status_code发送响应行，并自动发送一个标题:&quot;Content-Length&quot;或 &quot;Transfer-Encoding&quot;。如果content_length为负，则发送“Transfer-Encoding: chunked”报头，否则发送“Content-Length”报头。如果转换编码被分割，那么消息体必须使用mg_send_http_chunk()或mg_printf_http_chunk()函数发送。否则，必须使用mg_send()或mg_printf()。额外的标题可以通过extra_headers设置。注意，extra_headers不能被一个新的行终止*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mg_printf_html_escape</span><span class="params">(struct mg_connection *nc, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span></span>;</span><br><span class="line"><span class="comment">/*发送一个打印格式的HTTP块，转义HTML标记*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mg_http_reverse_proxy</span><span class="params">(struct mg_connection *nc,</span></span></span><br><span class="line"><span class="params"><span class="function">                           <span class="keyword">const</span> struct http_message *hm, struct mg_str mount,</span></span></span><br><span class="line"><span class="params"><span class="function">                           struct mg_str upstream)</span></span>;</span><br><span class="line"><span class="comment">/*将给定的请求代理给给定的上游http服务器.挂载中的路径前缀将被剥离到上游服务器请求的路径，例如如果挂载为/api，上游为 http://localhost:8001/foo 那么向/api传入的请求将传入到 http://localhost:8001/foo/bar*/</span></span><br></pre></td></tr></table></figure>



<h3 id="HTTP-Client端API"><a href="#HTTP-Client端API" class="headerlink" title="HTTP Client端API"></a>HTTP Client端API</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">struct mg_connection *<span class="title">mg_connect_http</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    struct mg_mgr *mgr,</span></span></span><br><span class="line"><span class="params"><span class="function">    MG_CB(<span class="keyword">mg_event_handler_t</span> event_handler, <span class="keyword">void</span> *user_data), <span class="keyword">const</span> <span class="keyword">char</span> *url,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> <span class="keyword">char</span> *extra_headers, <span class="keyword">const</span> <span class="keyword">char</span> *post_data)</span></span>;</span><br><span class="line"><span class="comment">/*创建出站HTTP连接的助手函数</span></span><br><span class="line"><span class="comment">url是要获取的url。它必须被正确地url编码，例如没有空格，等等.默认情况下，mg_connect_http()发送连接和主机头</span></span><br><span class="line"><span class="comment">extra_headers是一个额外的HTTP头:&quot;User-Agent: my-app\r\n&quot;</span></span><br><span class="line"><span class="comment">如果post_data为空，则创建一个GET请求。否则，将使用指定的POST数据创建POST请求。</span></span><br><span class="line"><span class="comment">注意，如果要提交的数据是表单提交，那么应该相应地设置Content-Type报头(参见下面的示例)。</span></span><br><span class="line"><span class="comment">nc1 = mg_connect_http(mgr, ev_handler_1, &quot;http://www.google.com&amp;quot;, NULL,</span></span><br><span class="line"><span class="comment">                        NULL);</span></span><br><span class="line"><span class="comment">nc2 = mg_connect_http(mgr, ev_handler_1, &quot;https://github.com&amp;quot;, NULL, NULL);</span></span><br><span class="line"><span class="comment">nc3 = mg_connect_http(</span></span><br><span class="line"><span class="comment">      mgr, ev_handler_1, &quot;my_server:8000/form_submit/&quot;,</span></span><br><span class="line"><span class="comment">      &quot;Content-Type: application/x-www-form-urlencoded\r\n&quot;,</span></span><br><span class="line"><span class="comment">      &quot;var_1=value_1&amp;var_2=value_2&quot;);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">struct mg_connection *<span class="title">mg_connect_http_opt</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    struct mg_mgr *mgr, MG_CB(<span class="keyword">mg_event_handler_t</span> ev_handler, <span class="keyword">void</span> *user_data),</span></span></span><br><span class="line"><span class="params"><span class="function">    struct mg_connect_opts opts, <span class="keyword">const</span> <span class="keyword">char</span> *url, <span class="keyword">const</span> <span class="keyword">char</span> *extra_headers,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> <span class="keyword">char</span> *post_data)</span></span>;</span><br><span class="line"><span class="comment">/*创建出站HTTP连接的助手函数.与mg_connect_http基本相同，但允许提供额外的参数(例如SSL参数)*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mg_http_create_digest_auth_header</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">size_t</span> buf_len,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      <span class="keyword">const</span> <span class="keyword">char</span> *method, <span class="keyword">const</span> <span class="keyword">char</span> *uri,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      <span class="keyword">const</span> <span class="keyword">char</span> *auth_domain, <span class="keyword">const</span> <span class="keyword">char</span> *user,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      <span class="keyword">const</span> <span class="keyword">char</span> *passwd)</span></span>;</span><br><span class="line"><span class="comment">/*为客户机请求创建摘要身份验证头*/</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux网络编程</category>
      </categories>
      <tags>
        <tag>mongoose</tag>
      </tags>
  </entry>
</search>
